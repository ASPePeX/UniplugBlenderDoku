\mysection{Alexander Scheurer}{Fazit und Ausblick}

Trotz dem, dass es der Forschungsgruppe bisher nicht gelungen ist eine Kommunikation zwischen Blender und \CS zu schaffen, schätzt die Forschungsgruppe die technischen Gegebenheiten so ein, dass es auf dem gezeigten Weg prinzipiell trotzdem möglich ist. Allerdings hat sich die Einschätzung der in den \nameref{sec:Vorueberlegungen} getroffenen Entscheidungen sehr stark verändert.

Der Implementierung- und Wartungsaufwand für mehrere 3D-Softwareprodukte ist sehr viel höher als erwartet, was in den zuvor dargelegten Problemen mit Swig (\ref{sec:SWIG}) begründet liegt. SWIG ist (noch?) nicht dazu geeignet eine Übersetzung für \todo{X-Dröfzigzausendstel} Interfaces durchzuführen.

Die Forschungsgruppe empfiehlt für weitergehende Versuche der Entwicklung eines Uniplugs, die zu übersetzenden Funktionen zu evaluierten und nativ für die jeweilige 3D-Software eine Plugin als Zwischenschicht für die Übersetzung zu entwickeln.

%Technische Umsetzung wahrscheinlich möglich allerdings sehr hoher Aufwand bei Wartung und Anbindung neuer Software.
%Logische Umsetzung sehr Komplex, je höher die Betrachtungsweite an Software ist.

%Andere Herrangehensweise wählen ... Zwischenlayer nativ für die Software zugeschnitten, dann Übersetzung nach \CS und Anbindung zu Fusee.

\subsubsection{Aussicht}

Aktuell werden die in Abschnitt \ref{sec:comments} beschriebenen Kommentare noch nicht nach \CS übernommen. Solange das eigentliche Uniplug, das die Schnittstellen verschiedener APIs vereinheitlichen soll, in Entwicklung ist, sollte daher automatisiert eine Doku erstellt werden, die die Entwicklung eigener Plugins vereinfacht. Ebenso wäre dies für Entwickler hilfreich, die abseits des Uniplugs die durch dieses Forschungsprojekt entstandene \CC-API für Blender nutzen möchten.

Bisher muss das \emph{BlenderPlug}-Plugin noch manuell initialisiert werden. Es ist aber möglich, über ein direkt in Python geschriebenes Plugin, das unter dem Namen \emph{\_\_init\_\_.py} ebensfalls in den Unterordner Fusee im Blender-Verzeichnis gelegt wird, das Plugin entweder automatisch auszuführen oder Kontextmenüeintäge anzulegen, über die die im Plugin implementierte Funktionalität ausgeführt werden kann. Mehr Informationen hierzu finden sich in der Blender-Doku\footnote{\url{https://www.blender.org/api/blender_python_api_2_75_3/info_tutorial_addon.html}}. Je nach Aufbau könnten so mehrere Plugins im Uniplug gebündelt werden (Exportfunktionalität, Szenenfunktionalität, etc.) oder ein Event-System (Aufruf einer speziellen Funktion beim Start vom Blender, Aufruf einer Funktion beim Beenden von Blender, etc.) aufgebaut werden. Dies sollte in Zukunft ebenso weiter verfolgt werden wie die Entwicklung von Beispielplugins und insbesondere eines zur C4D-Variante des Uniplugs vergleichbaren Exportplugins, das es erlaubt die Szene als FUSEE-Web-Anwendung zu exportieren und so im Web anzuschauen.

Ein Problem ist auch, dass alle DLL-Dateien (\emph{CsWrapper.dll, CsClient.dll}, etc.), die für die korrekte Ausführung der in \CS implementierten Plugin-Funktionalität benötigt werden, im Hauptverzeichnis von Blender liegen müssen, da sie sonst nicht gefunden werden. Hier müsste der Assembly-Suchpfad durch entsprechende Programmierung oder Konfiguration angepasst werden. Dadurch wäre es ausreichend, dass alle Dateien im Unterordner Fusee im Addon-Unterordner des Hauptverzeichnisses liegen.


Des Weiteren sollte das System an das System angepasst werden, das aktuell bereits beim Uniplug für Cinema4D zum Einsatz kommt. Hier wird bspw. ein Ordner nach \CS-Plugins durchsucht und diese per Reflection ausgeführt, sodass nicht nur ein einziges \CS-Plugin verwendet werden kann. Ebenso sollte die Nutzung auf anderen Betriebssystem vorbereitet werden, indem, wie es auch beim C4D-Uniplug möglich ist, Mono als alternative .NET-Runtime ermöglicht wird. Das automatische Aufrufen von .NET-Funktionen aus einer \CC-DLL heraus wie es hier von BlenderPlug nach ManagedBridge gemacht wird, ist aktuell nur unter Windows möglich.

In \CS{} ist es möglich für Properties sogenannte Auto-Setter und -Getter zu verwenden, sodass Anweisungen wie \emph{pyUniplug.Context().Scene()...} zu \emph{pyUniplug.Context.Scene...} vereinfacht werden können. Dies ist zwar hauptsächlich eine Aufgabe von SWIG, möglicherweise sind aber bereits Vorbereitungen in der C++-Header-Datei notwendig, sodass SWIG solche Auto-Setter und -Getter erstellen kann. Denkbar wäre bspw. das Anlegen von (in \CC) ungenutzten \enquote{Dummy}-Feldern innerhalb der Klassen, sodass bei der Verarbeitung durch SWIG diese als Properties und nicht als Funktionen erkannt und um den Aufruf der eigentlichen Setter- und Getter-Funktionen (deren Access-Modifier im gleichen Schritt auf \emph{private} geändert werden können) erweitert wird.

Zwangsläufig muss durch die längere Prozesskette von \CS{} über SWIG und \CC nach Python ein Performanceverlust in Kauf genommen werden. Der Flaschenhals ist dabei aber weniger im Bereich SWIG zu erwarten, da Aufrufe von \CS{} in exportiere C/\CC-Funktionen letztlich nur wenig Mehraufwand bedeuten, sondern im speziellen durch den Aufruf von Python-Funktionen in der Header-Datei. Hier wird zusätzlich zu den Konvertierungen der PyObject-Objekte in Basistypen und umgekehrt auch immer wieder mit String-Operationen gearbeitet. Zudem ist insbesondere beim allerersten Initialisierungsaufruf des Uniplugs eine merkliche Verzögerung von 1 - 2 Sekunden messbar, da hier zunächst im Hintergrund die .NET-Runtime initialisiert werden muss. Weitere Aufrufe der in \CS{} implementierten Uniplug-Funktionen sind dann aber zumindest nicht merklich verzögert. Dennoch sollten hier einige präzise Messungen vorgenommen werden, um allgemeine Aussagen über den Performanceverlust zu treffen und so herauszufinden, ob diese im Alltag relevant sind. Es ist in der Regel zwar nicht davon auszugehen, dass mit die FUSEE/Uniplug geschriebenen Plugins zeitkritische Aufgaben bearbeiten müssen, denkbar wäre es aber dennoch. Auf Basis der sich dadurch ergebenden Erkenntnisse wären eventuell weitere Optimierungen (bspw. das Cachen der Ergebnisse von Python-Funktionsaufrufen, etc.) möglich.