\mysubsection{Fabian Gärtner}{C++-API für Blender: die Header-Datei}\label{sec:header}

\subsubsection{Vorüberlegung}

Da Blender im Gegensatz zu 3D-Modellierungsprogrammen wie Cinema4D oder 3ds Max nur über eine Python-API, nicht aber über eine \CC-API verfügt, musste zunächst eine Möglichkeit gefunden werden, Blender dennoch mittels \CC{} anzusteuern. Zwar ist Blender quelloffen, sodass hier über Modifizierungen des Quelltexts pluginartige Erweiterungen vorgenommen werden könnten. Dies hätte aber zur Folge, dass Nutzer des Uniplugs gezwungen wären, eine bestimmte Blender-Version zu verwenden oder gar Blender selbst zu bauen (siehe dazu den in Abschnitt \ref{sec:buildblender} beschrieben Aufwand). Um diese Problematik zu vermeiden, wurden im Laufe des Projekts verschiedene Methoden evaluiert, mit denen von \CC aus die Python-API von Blender aufgerufen werden kann.

Eine der ersten Versuche bezogen sich dabei auf das Python-Modul \emph{ctypes}, das es erlaubt, in Python externe C- bzw. \CC-DLLs zu laden und die in den DLL implementierte Funktionalität auszuführen. Dies stellte sich allerdings schnell aus mehreren Gründen als ungeeignet für das Projekt heraus. Zum einen hätte das System hauptsächlich nur einseitig funktioniert, das heißt von Python aus hätten \CC-Funktionen aufgerufen werden können, aber keine Python-Funktionen von \CC{} aus. Einzig über Callbacks, die aber letztlich auch wieder von Python heraus gesetzt und aufgerufen werden müssen, wäre dies möglich gewesen. Zum anderen aber hätte bei jeder Kommunikation auch eine Typumwandlung stattfinden müssen, da ctypes mit speziellen Datentypen arbeitet, die nicht implizit in C-Datentypen konvertiert werden können.

Ein ganz allgemeines weiteres Problem war die Tatsache, dass zunächst keine Liste der Funktionen der Blender-API verfügbar war. Diese wird aber benötigt, damit SWIG daraus entsprechende \CS-Funktionen erzeugen kann. Über die Python-Funktion \emph{dir()} hätte zwar ein geladenes Plugin über alle Typen und deren Funktionalitäten iterieren können, dies wäre aber weder effektiv noch zielführend gewesen. Dann wären nämlich die jeweiligen Funktionen, nicht aber deren Parameter bzw. die Typen der Parameter bekannt gewesen. Zur Lösung dieses Problems war ein erster Versuch, die im Blender-Quelltext (bzw. insbesondere im Quelltext des Tools \emph{MakesRNA}) vorhandenen Dateien zu parsen, da diese jegliche später in der Blender-API verfügbare Funktionalität in einer speziellen Syntax und durch Erweiterung von Python deklarieren. Listing \ref{lst:locdecl} zeigt dies beispielhaft anhand einer Property der Klasse \emph{Object}. Deklariert werden hier Typ, Beschreibung und andere Eigenschaften. Ein erstes auf regulären Ausdrücken basiertes Tool zeigte allerdings Probleme bei Strukturen, deren Deklaration von der Regel abwich. Alles in allem wäre diese Vorgehensweise daher zu aufwändig und zu fehleranfällig gewesen.

\begin{code}[caption={Deklaration der Property \protect\emph{location} der Klasse \protect\emph{Object} in \protect\emph{rna\_object.c}},label={lst:locdecl}]
	prop = RNA_def_property(srna, "location", PROP_FLOAT, PROP_TRANSLATION);
	RNA_def_property_float_sdna(prop, NULL, "loc");
	RNA_def_property_editable_array_func(prop, "rna_Object_location_editable");
	RNA_def_property_ui_text(prop, "Location", "Location of the object");
	RNA_def_property_ui_range(prop, -FLT_MAX, FLT_MAX, 1, RNA_TRANSLATION_PREC_DEFAULT);
	RNA_def_property_update(prop, NC_OBJECT | ND_TRANSFORM, "rna_Object_internal_update");
\end{code}

\subsubsection{MakesRNA}

Stattdessen wurde daher das in C geschriebene Tool MakesRNA genauer untersucht, da dieses die angesprochenen Dateien nicht nur oberflächlich parst, sondern direkt ausführt und so eine Reihe von weiteren Quelltext-Dateien erzeugt, die beim späteren Bau von Blender Python um eben jene Funktionalität erweitern. Daraus ergaben sich zwei Erkenntnisse: Zum einen zeigte sich so, dass Python relativ simpel um eigene C++-Module erweitert werden kann\footnote{Siehe hierzu auch {https://docs.python.org/3.5/extending/index.html}} (dies ist auch der Hauptzweck des MakesRNA-Tools) und zum anderen, dass ein Umbau des MakesRNA-Tools das gewünschte Ziel, nämlich eine Liste aller in Blender vorhandenen API-Strukturen zu erzeugen, ermöglichen würde. Die Idee war daher, mit Hilfe dieses Tools eine \enquote{simple} Header-Datei zu erzeugen, in der jegliche Blender-API-Klassen, -Methoden, -Properties, etc. in \CC{} deklariert sind und die diese Aufrufe durch Einbindung der Python-Header-Datei mittels Python-Funktionen wie \emph{PyObject\_GetAttrString} oder \emph{PyObject\_CallMethod} an Python und damit an Blender weiterreicht. So sollte also vereinfacht gesagt bei Ausführung des Tools automatisiert ein \CC{}-Wrapper für die Blender-API erstellt werden. Da das MakesRNA-Tool aber Teil des kompletten Blender-Projekts ist und, wie eben erwähnt, benötigt wird, um Blender selbst zu bauen, wurde von der Forschungsgruppe festgelegt, dass dieses Tool lediglich durch einen speziellen FUSEE-Modus erweitert werden soll, ohne dabei die eigentliche Funktionalität des Tools im normalen Einsatz zu stören. 

Im Folgenden nun zunächst eine Anleitung, um den Quelltext von Blender und damit auch den Quelltext von MakesRNA zu beziehen. Anschließend folgt dann eine nähere Erläuterung der während des Forschungsprojekts vorgenommenen Erweiterungen zur Erreichung der angestrebten Funktionalität,

\paragraph{Bezug des Quelltextes}
\label{sec:buildblender}

Blender verwendet Git\footnote{\url{https://git.blender.org/gitweb/}} zur Versionierung seines Quelltextes. Allerdings werden zum Bau der Unterprojekte eine Vielzahl an externen Bibliotheken benötigt. Da diese mit einer Gesamtgröße von rund 10 Gigabyte nicht mit Git versioniert werden können, verwendet Blender zusätzlich zum eigenen Git-Server auch einen SVN-Server\footnote{\url{https://svn.blender.org/svnroot/bf-blender/trunk/}}. Entsprechend komplex ist es, das Projekt und alle Abhängigkeiten korrekt zu beziehen. Hinzu kommt, dass anschließend mittels CMake zunächst die entsprechenden Projektdateien für den gewünschten Compiler erzeugt werden müssen. Um diesen kompletten Prozess zu vereinfachen, wurde daher von der Forschungsgruppe zunächst ein einfaches Shell-Script erstellt, das alle benötigten Dateien herunterlädt und anschließend eine Solution für VisualStudio 2013 mittels CMake erzeugt. Des Weiteren wurden zwei Repositories auf GitHub angelegt. Das Repository \emph{blender}\footnote{\url{https://github.com/InformatischesQuartett/blender}} ist ein Fork vom offiziellen Repository inklusive aller Änderungen, die im Rahmen dieses Forschungsprojektes vorgenommen wurden. Dieses Repository ist als Submodule in das Repository \emph{MotherBase}\footnote{\url{https://github.com/InformatischesQuartett/MotherBase}} eingebunden, das neben dem eben erwähnten Skript auch die benötigten Ordner und eine aktuelle Version von CMake bereitstellt.

Es sind daher nun nur noch wenige einfache Schritte notwendig, bevor Blender (und die Unterprojekte wie MakesRNA) gebaut werden können. Als erster Schritt muss ein Git- und ein SVN-Tool installiert werden und die Pfade zu diesen Tools müssen der Umgebungsvariable \emph{PATH} hinzugefügt werden. Anschließend kann das MotherBase-Repository bezogen und über den Befehl \emph{./make.sh} aus der Git-Konsole heraus die \enquote{Installation} gestartet werden. Das Submodule blender wird selbstständig geupdated, ebenso werden mittels SVN alle notwendigen Abhängigkeiten heruntergeladen oder aktualisiert und anschließend über CMake die Solution erstellt. Dieser Prozess kann aufgrund der Größe der Dateien einige Zeit in Anspruch nehmen. Anschließend sollte im Ordner \emph{cbuild} die Solution \emph{Blender.sln} liegen, die nun als x64-Release gebaut werden könnte. Zum regelmäßigen Aktualisieren des Forks stehen die beiden Dateien \emph{update1.sh} und \emph{update2.sh} zur Verfügung. Diese sollten in dieser Reihenfolge über die Git-Konsole ausgeführt werden. Da es zu Merge-Konflikten kommen könnte, ist der Updateprozess zweigeteilt. Nach Ausführen von update1.sh können so erst mögliche Konflikte behoben werden und anschließend das Update fortgesetzt werden. Abschließend aktualisieren die Skripte automatisch die beiden Repositories und pushen die Änderungen selbstständig mit Datumsangabe in der Commit-Message.

\paragraph{FUSEE-Modus im Projekt MakesRNA}

Innerhalb der Blender.sln befindet sich das Projekt MakesRNA, wobei die für das Forschungsprojekt notwendigen Änderungen hauptsächlich an der Datei \emph{makesrna.c} vorgenommen wurden. Hier wurden zwei neue Kommandozeilenparameter \emph{--fusee} und \emph{--nocomment} eingeführt, die das Tool in den FUSEE-Modus versetzen. Alle relevanten Funktionen im Quelltext des MakesRNA-Projekts fragen den aktuellen Modus ab und erzeugen so ggf. statt den vielen verschiedenen für Blender notwendigen Dateien nur noch eine einzige Header-Datei erzeugt, die wie oben erwähnt die Blender-API wrapt. Diese Datei kann auch direkt von \CC{} aus (also unabhängig von FUSEE und Uniplug) verwendet werden. Daher handelt es sich hier bereits um eine vollständige \CC-API für Blender, die all das ermöglicht, was auch aus Python mittels Blender-API möglich wäre.

Im Folgenden nun eine genauere Übersicht über alle Unterschiede und vorgenommen Änderungen an Datentypen, Funktionen, etc. im Vergleich zum normalen Modus des MakesRNA-Tools.

\paragraph{Datentypen}

Da die von MakesRNA üblicherweise erstellen Dateien in C-Syntax geschrieben sind, werden im normalen Modus keine \CC-Datentypen verwendet. Des Weiteren werden hier normalerweise mittels \#define-Direktiven eigene Datentypen definiert, die spezielle Speichermechanismen implementieren. Da dies für dieses Forschungsprojekt und für das Uniplug irrelevant ist und die Header-Datei die im Vergleich zu C modernere \CC-Syntax verwenden kann, wurden Änderungen an den Datentypen vorgenommen. In aller Regel werden Basistypen verwendet (\emph{int, bool, float}) mit Ausnahme von Arrays, \emph{Collections} und Strings in Form von \emph{char}-Pointern. Letztere wurden durch \emph{std::strings} ersetzt. Für Arrays werden im normalen Modus in der Regel Pointer eingesetzt (bspw. zur Rückgabe von Array-Daten bei Funktionen). Da aber auf Pointer verzichtet werden sollte, um Speicherlecks zu vermeiden, war zunächst geplant, diese durch das in \CC{} bekannte \emph{std::array<>} zu ersetzen. SWIG hat allerdings Probleme std::array (und im allgemeinen Nicht-POD-Strukturen) korrekt nach \CS{} zu übersetzen und im späteren Prozess daraus die von FUSEE bekannten Datentypen \emph{float2, float3}, usw. zu generieren. Daher deklariert das MakesRNA-Tool für alle möglichen Array-Arten (int-, float-, bool-Arrays mit Längen 1, 2, 3, etc.) eigene Datentypen im Stil \emph{VFLOAT3} (entspricht \emph{std::array<float, 3>}, bzw. \emph{float[3]} bzw. \emph{float3}). Dazu werden im Vorfeld alle Properties und alle Parameter von Funktionen analysiert und die entsprechend notwendigen Datentypen mittels \#define-Direktive zu Beginn der Header-Datei deklariert. Siehe dazu Listing~\ref{lst:vfloat}. Die entsprechenden Structs verfügen über ein \emph{data}-Feld, das das eigentliche Array darstellt und über Operator-Overloading für den Subscript-Operator ([ ]), um mit der gewohnten Syntax auf die Daten des Arrays zuzugreifen. Dies hat auch zum Vorteil, dass in der gesamten Header-Datei weiterhin mit der gewohnten Array-Syntax gearbeitet werden kann und lediglich die Datentypen durch die selbstdeklarierten Datentypen ersetzt werden mussten. Der Name diese Datentypen weist den Nutzer dabei gleichzeitig auf die Anzahl an gespeicherten Werten hin, was insbesondere dadurch relevant ist, dass noch nicht für alle Vector-Datentypen ein entsprechendes FUSEE-Äquivalent existiert. Die beiden Funktionen \emph{get\_value} und \emph{set\_value} sind hauptsächlich für die spätere Übersetzung nach \CS{} gedacht, wo diese dann vom in \CS{} definierten Subscript-Operator aufgerufen werden.

\begin{code}[caption={Deklaration der Vektordatentypen mittels \protect\#define},label={lst:vfloat}]
#define DEFINE_VECTOR_POD(sname, stype, slength)\
	struct V##sname##slength {\
	private:
		stype data[slength];\
	public:\
		stype get_value(const int idx) { return data[idx]; }\
		void set_value(const int idx, stype value) { data[idx] = value; }\
		stype& operator[] (const int idx) {return data[idx];}\
	};

DEFINE_VECTOR_POD(FLOAT, float, 2);  // etc.
\end{code}

Dynamische Arrays (teilweise Pointer) wurden in \emph{std::vector<>} geändert. Diese kann SWIG selbstständig in \CS{}-Listen übersetzen. Damit erfüllen sie sowohl in \CC{} als auch in \CS{} die Aufgabe, eine dynamische Menge an Daten abspeichern zu können. Collections hingegen (in der Blender-API Ansammlungen von Key-Value-Paaren mit eigenem Speichermanagement) wurden in \mbox{\emph{std::maps<string, *>}} geändert. Diese können von SWIG später in \CS{}-Dictionaries übersetzt werden, sodass bspw. Objekte in der 3D-Szene durch ihren Namen abgefragt werden können. Dazu muss SWIG allerdings eine Liste an verwendeten Key-Value-Paaren zur Verfügung gestellt werden. Daher wird im FUSEE-Modus zusätzlich eine Interface-Datei für SWIG erstellt, in der alle std::maps-Typen aufgelistet sind.

Ein weiter Sonderfall sind Enum-Typen. Da Python bzw. die Blender-API Enum-Werte nur in Form von Strings zurückliefert und entsprechend Strings bei der Zuweisung von Enum-Typ-Variablen erwartet, dies aber für Programmierer natürlich ein Problem darstellt, werden in der Header-Datei Konvertierungsfunktionen, die Enum-Werte in Strings und Strings in Enum-Werte konvertieren, deklariert. Ein Beispiel für solche Konvertierungen ist in Listing \ref{lst:enumconv} zu finden. Hier werden zwei std::maps angelegt, die jeweils entweder ein String annehmen und ein int zurückliefern oder umgekehrt ein int annehmen und einen entsprechenden String zurückliefern. Dass diese Funktionen einen numerischen Wert und nicht gleich einen Enum-Typ zurückliefern liegt am Template-Prinzip, das der std::maps-Klasse zugrunde liegt. Der Compiler legt zur Compilezeit für jedes std::map der Form \emph{std::map<std::string, example\_enum>} eine konkrete Klasse an. Dies heißt zwangsläufig, dass für jeden neuen Enum-Typ eine solche Klasse angelegt werden müsste (und zwar jeweils einen für die Hin- und Rücktransformation). Bei ersten Tests endete dies in Compilezeiten von mehreren Minuten, teilweise auch in Speicherüberläufen. Daher wird nun stattdessen immer nur std::string und int als Key-Value-Paare verwendet und durch implizites und explizites casten (letzteres mit \emph{static\_cast<example\_enum> enum\_valu}e) bei Bedarf der entsprechende Enum-Typ erzeugt. 

\begin{code}[caption={Konvertierung von Enum-Typen in Strings und umgekehrt},label={lst:enumconv}]
 		std::map<std::string, int> create_string_to_smoked_type_items() {
			return { { "SMOKEDENSITY", smoked_type_items_SMOKEDENSITY }, /* ... */ };
		};

		std::map<int, std::string> create_smoked_type_items_to_string() {
			return { { smoked_type_items_SMOKEDENSITY, "SMOKEDENSITY" }, /* ... */ } };
		};

		std::map<std::string, int> string_to_smoked_type_items = create_string_to_smoked_type_items();
		std::map<int, std::string> smoked_type_items_to_string = create_smoked_type_items_to_string();
\end{code}

Damit nun nicht bei jeder einzelnen Übersetzung wiederum die Map neu erzeugt werden muss, wurden die entsprechenden Variablen als Klassenattribute angelegt und eine entsprechende Map-Erzeugungsfunktion implementiert, sodass diese Maps beim Erzeugen der Klasse erstellt werden. Schön wäre es hier zwar gewesen, die Attribute als \emph{static-const}-Variablen zu deklarieren, da sie dann zum einen nicht mehr geändert werden könnten nach der Initialisierung und zum anderen klassen- statt objektspezifisch wären, dies ist aber in der jetzigen Form nicht möglich. Zum einen darf der \CC{}-Compiler laut den Spezifikationen keinen impliziten Copy- und Zuweisungs-Konstruktor anlegen, wenn nicht-statische Variablen als \emph{const} deklariert wurden. Beim Erzeugen von Objekten werden die Werte aller Variablen des alten Objekts in die des neuen Objekts kopiert. Da dies bei Konstanten logischerweise nicht geht, werden in einem solchen Fall implizite Konstruktoren aus der Klasse entfernt. Zum anderen handelt es sich bei std::maps nicht um Basistypen. Daher sind diese Felder aktuell lediglich als gewöhnliche Felder angelegt.

\paragraph{Stukturen}

Deklarationen und Implementierungen: Alle Deklarationen (insbesondere also alle Klassen) sind in einer einzigen Datei deklariert. Im Folgneden eine Übersicht über gängige Programmierstrukturen und Ihre Implementierung im C++-Header-Datei.

\subparagraph{Klassen}

Es werden die meisten im MakesRNA-Tool definierten Klassen deklariert. Lediglich einige Basisklassen (bspw. die Klasse RNA\_Pointer), die nur für das interne Management zuständig sind, aber keine für den Nutzer relevante Funktionalität implementieren, werden ignoriert. Stattdessen wurde eine Basisklasse PyObjRef angelegt, die sich um Speicherung der Referenz und um das Speichermanagement kümmert. Die Rückgabewerte der Python-Funktionen (Pointer auf Objekte der Klasse PyObject) verweisen dabei auf Objekte, die anschließend weiter verarbeitet werden können (bei Sequenzen z.B. durch die Abfrage der einzelnen Items, die wiederum Pointer auf PyObject-Objekte sind). Je nach internem Python-Typ können diese auch in C-Typen konvertiert werden. Die Referenz auf diese Objekte wird in der Property pyobjref gespeichert.

Da Python ein Referenzzähler-System verwendet, um den Speicher der nicht mehr referenzierten PyObject-Objekte freizugeben, muss sich auch die Header-Datei um die korrekte Referenzzählung kümmern. Der Auffruf der Python-Funktionen erhöht in aller Regel den Referenzzähler für das zurückgegebene PyObject. Werden nun in der Header-Datei neue Objekte erzeugt, die jeweils auf das gleiche PyObject verweisen, müssen auch hier die Referenzzähler erhöht werden. SWIG bspw. verwendet bei der späteren Übersetzung allerdings nicht nur den Standardkonstruktor, sondern ruft ebenso sowohl den Kopierkonstruktor als auch den Zuweisungskonstruktor auf. Daher müssen alle drei Konstruktorarten in der Header-Datei explizit deklariert werden, sodass in allen drei Fällen auch der Referenzzähler des referenzierten Objektes erhöht wird. Da aber alle Klassen direkt oder indirekt von PyObjRef erben, ist es auchreichend, wenn diese Fuktionalität in der PyObjRef-Klasse implementiert ist. Ebenso ist in dieser Klasse ein Destruktor deklariert, der den Referenzzähler wieder verringert. Lediglich, wenn Python zu diesem Zeitpunkt nicht mehr intilaisiert ist (PyInitzialed ist dann null), also insbesondere wenn Blender gerade beendet wird, wird dieser Schritt übersrpungen, da es ansonsten zu Access-Violations käme. Der Speicher wird in diesem Fall so oder so gerade von Windows freigegeben.

\subparagraph{Properties}

Jegliche PRoperties liegen als Setter und Getter-Funktionen vor. Diese Getter-Funktionen geben den Aufruf an die Funktion PyGetAttr weiter, die ein PyObjekt und die abzufragende Property als String entgegentnimmt. Das Ergebnis ist wie oben bereits beschrieben ein weiterer Pointer auf ein PyObjekt. Dieses kann dann je nach Rückgabewert entweder in ein C++-Basityp konvertiert werden oder durch Aufruf der entsprechenden Konstrukturoren und durch Weitergabe der Referenz an die dadurch erzeugten Objekte auch in ein Objekt einer im Header-Datei deklarierten Klasse erzeugt werden. Bei den Settern wird entsprechend umgekehrt ein Basistyp oder ein Objekt angenommen und dieses zunächst in ein PyObjekt konvertiert und anschließend durch PyAttrSet wiederum mit Referenz und Property-Name als String an Python weitergereicht.

Da diese Konvertierungen und Aufrufe sich grundsätzlich über mehrere Zeilen erstrecken (bei Konvertierung in ein Array bis zu 8 Zeilen inkl. Speichermanagement) ergeben sich bei mehr als 1000 Klassen mit teilweise mehreren Dutzen Properties Unmengen an sich wiederholendem Code. Daher wurde hierfür und für die im folgenden Abschnitt beschriebenen Funktionen ein System aus \#define-Direktiven definiert, dass jegliche PRoperties auf eine Zeile reduziert und damit die Dateigröße stark reduziert. Die Namen der \#define-Direktiven wurde dabei so gewählt, dass deren Funktion sich direkt aus dem NAmen ergibt. So ergibt sich eine optimale Moschung aus Effizienz und Code-Verständlichkeit.

\subparagraph{Funktionen}

Funktionen stellen mitunter die größte Herausforderung dar. Dies hat mehrere Gründe. Zum einen können Funktionen in Python mehrere Rückgabewerte besitzen. Das MakesRNA-Tool markiert dazu ein oder mehrere Parameter der Funktion mit einem Out-Flag. Dieses Flag wird im FUSEE-Modus verwendet, um herausfinden, bei wie vielen und insbesondere bei welchen Parametern es sich eigentlich um Rückgabewerte handelt. Am einfachsten wäre es nun gewesen, diese Parameter beispielsweise als Call-By-Reference- oder Call-by-Pointer-Parameter zu definieren. Ein Nachteil wäre aber gewesen, dass Parameter, für die ein Defaultwert definiert ist, diesen nicht hötten..... Auch wäre die Verwendung in \CS{} möglicherweise komplexer gewesen. Daher wird im FUSEE-Modus entweder, wenn es sich nur um ein Rückgabewert handelt, dieser entsprechend als Return-Value definiert und der Parameter entfernt, oder aber, wenn es zwei oder mehr Rückgabewerte sind, automatisiert ein Struct angelegt, dass alle Rückgabewerte bündelt und die entsprechenden Parameter entfernt. So haben alle Funktionen nun tatsächlich nur noch Call-by-Value-Parameter und können entsprechend in \CS{} verwendet werden...

die Implementierung verwendet wie bei den Properties mehrere \#define-Direktiven, die... So müssen alle Parameter entsprechend umgewandelt werden (Arrays in PySequences, etc.), dann die Python-Funktion aufgerufen und alle Rückgabewerte wieder zurückgewandelt werden. Sind es mehrere, so wird das automatisch angelegte Struct mit Daten gefüllt und zurückgegeben. Wird das Objekt einer Klasse zurückgegeben, so wird das Objekt erzeugt und die Python-Referez übergebene. 

\subparagraph{Kommentare}

Das MakesRNA-Tool definiert bereits für viele Klassen, Properties, Funktionen, Enums, etc. Hilfstexte, die in Blender ... Im FUSEE-Modus werden diese Texte direkt als Kommentare an den entsprechenden Stellen in der Header-Datei verwendet. Diese sind direkt im javadooooo-Style, sodass mit Hilfe von Doxygen oder anderen Programmen eine Dokumentation für die Header-Datei erzeugt werden könnte. Da die Kommentare aber etwa 1 MB bei der Größe der Header-Datei ausmacht, können diese auch deaktiviert werden, dann MakesRNA mit dem Argument "--nocomment" gestartet wird.

\subsubsection{ManagedBridge}

Da Blender bzw. Python nur C++-Module laden kann, muss eine Brücke zum \CS{}-Plugin hergestellt werden, sodass von C++ aus auf \CS{}-Funktionalität zurückgegriffen werden kann. Dies kann unter Windows über ein Managed-C++-Plugin erreicht werden. Letztlich referenziert dieses lediglich das \CS{}-Plugin, ruft dessen Funktionen auf und exportiert die entsprechenden Funktionsaufrufe, sodass sie von C++ aus aufgerufen werden können.

\subsubsection{BlenderPlug}

Das Projekt BlenderPlug ist das eigentliche C++-Modul, das in Blender geladen werden kann und schließlich die Init-Funktion (oder andere Funktionen) bereitstellt, um über die ManagedBridge hinweg auf die \CS{}-Funktionalität zuzugreifen.  Daszu muss das Plugin 

In Blender selbst kann dann in der Python-Konsole über "from fusee import uniplug" und "uniplug.init()" die Funktion ausgeführt werden. Siehe dazu auch das beigelegte Tutorial zur Erstellung eines eigenen Plugins

\subsubsection{Aussicht}

Aktuell muss das Plugin noch manuell intialisiert werden. Es ist aber möglich, über ein direkt in Python geschriebenes Plugin, das unter dem Namen "\_\_init\_\_.py" ebensfalls in den Ordner Fusee gelegt wird, Uniplug entweder vollautomatisch auszuführen oder Kontextmenüeintäge anzulegen, über die das Uniplug ausgeführt werden kann. Mehr Informationen hierzu finden sich in der Blender-Doku (URL). Je nach Aufbau könnten so mehrere Plugins im Uniplug gebündelt werden (Exportfunktionalität, Szenenfunktionalität, etc.) oder ein Event-System (Aufruf einer speziellen Funktion beim Start vom Blender, Aufruf einer Funktion beim Beenden von Blender, etc.) aufbaut werden. Dies sollte in Zukunft ebenso weiter verfolgt werden wie die Entwicklung von Beispielplugins und insbesondere eines zur C4D-Variante des Uniplugs vergleichbaren Exportplugins, das es erlaubt die Szene als FUSEE-Web-Anwendung zu exportieren und so im Web anzuschauen.

Basierend auf den in 2.2.3 beschriebenen Kommentarsystem sollte eine Doku erstellt werden, die Uniplug beigelegt wird, sodass dem Nutzer die Entwicklung eigener Plugins vereinfacht wird, solange das eigentliche Uniplug, das die Schnittstellen vereinheitlichen soll, in Entwicklung ist. Ebenso wäre dies für Entwickler hilfreich, die abseits des Uniplugs die durch dieses Forschungsprojekt entstandene C++-API für Blender nutzen möchten.

Das System mehr an das C4D-Uniplug anpassen, so dass letztlich der Ordner nach \CS{}-Plugins durchsucht und per Reflection ausführt. Ebenso sollte die Nutzung auf anderen Betriebssystem vorbereitet werden, indem, wie es auch beim C4D-Uniplug möglich ist, Mono als Alternative zu nutzen, sollte die .NET-Runtime nicht zur Verfügung stehen. Das automatische Aufrufen von .NET-Funktionen aus einer C++-DLL heraus ist aktuell nur unter Windows möglich.

In \CS{} wäre es möglich für jegliche Properties sogenannte Auto-Setter und -Getter zu verwenden, sodass Anweisungen wie "pyUniplug.Context().Scene()...." zu "pyUniplug.Context.Scene..." vereinfacht werden können. Dies ist zwar hauptsächlich eine Aufgabe von SWIG, möglicherweise sind aber bereits Vorbereitungen in der C++-Header-Datei notwendig, sodass SWIG solche Auto-Setter und -Getter erstellen kann. Denkbar wäre bspw. das Anlegen von (in C++) ungenutzten "Dummy"-Feldern innerhalb der Klassen, sodass bei der Verarbeitung durch SWIG diese als Properties und nicht als Funktionen erkannt und um den Aufruf der eigentlichen Setter- und Getter-Funktionen (deren Access-Modifier im gleichen zu auf "private" geändert werden könnte) erweitert wird.

Zwangsläufig muss durch die längere Prozesskette von \CS{} über SWIG nach C++ nach Python ein Performanceverlust in Kauf genommen werden. Der Flaschenhals ist dabei aber weniger im Bereich SWIG zu erwarten, da Aufrufe von \CS{} in exportiere C/C++-Funktionen letzlich nur wenig Mehraufwand bedeuten, sondern im speziellen durch den Aufuruf von Python-Funktionen in der Header-Datei. Hier wird zusätzlich zu den Konvertierungen der PyObject-Objekte in Basistypen und umgekehrt auch immer wieder mit String-Operationen gearbeitet (siehe hierzu auch Abschnitt 2....). Insbesondere ist beim allerersten Initialisierungsaufruf des Uniplugs eine merkliche Verzögerung von 1 - 2 Sekunden messbar, da hier zunächst im Hintergrund die .NET-Runtime initialisiert werden muss. Weitere Aufrufe der in \CS{} implementierten Uniplug-Funktionen sind dann aber zumindest nicht merklich verzögert. Dennoch sollten hier einige präzise Messungen vorgenommen werden, um allgemeine Aussagen über den Performanceverlust zu treffen und so herauszufinden, ob diese im Alltag relevant sind. Es ist in der Regel zwar nicht davon auszugehen, dass mit FUSEE/Uniplug geschriebenen Plugins zeitkritische Aufgaben bearbeiten müssen, denkbar wäre es aber dennoch.  Auf Basis der sich dadurch ergebenden Erkenntnisse wären eventuell weitere Optimierungen (auch in Hinblick auf die Dateigröße) möglich (Cachen der Ergebnisse von Python-Funktionsaufrufen, etc.).