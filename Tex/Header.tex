
\mysubsection{Fabian Gärtner}{C++-API für Blender: die Header-Datei}\label{sec:header}

\subsubsection{Vorüberlegung}

Da Blender im Gegensatz zu 3D-Modellierungsprogrammen wie Cinema4D oder 3dsmax nur über eine Python-API, nicht aber über eine C++-API verfügt, musste zunächst eine Möglichkeit gefunden werden, Blender dennoch mittels C++ anzusteuern. zwar ist Blender quelloffen, sodass hier über Modifizierungen des Quelltexts grßere Änderungen vorgenommen werden können, dies aber sollte vermideden werden, weil es Nutzer des Uniplugs zwingen würde, eine bestimmte Blender-Version zu verwenden, oder gar Blender selbst zu bauen (siehe dazu den in 2.1 beschrieben Aufwand). Um diese Problematik zu vermeiden, wurden im Laufe des Projekts verschiedene Methoden evaluiert, von C++ aus die Python-API von Blender zu erweitern. Eine der ersten Versuche bezogen sich dabei auf das Python-Modul ctypes, das es erlaubt, externe C/C++-DLLs zu laden und die in den DLL implementierte Funktionalität auszuführen. Dies stellte sich allerdings schnell aus mehreren Gründen als ungeeignet für das Projekt heraus. Zum einen hätte das System hauptsächlich nur einseitig funktioniert, das heißt in Python hätten C++-Funktionen aufgerufen werden können, aber nicht andersherum (außer über Callbacks, die aber letztlich auch wieder von Python heraus aufgerufen werden müssen). Zum anderen hätte bei jeder Kommunikation auch eine Typumwandlung stattfinden müssen, da ctypes mit speziellen Datentypen arbeitet, die nicht implizit in C-Datentypen konvertiert werden können.

Ein ganz allgemeines weiteres Problem war die Tatsache, dass zunächst keine Liste an allen in Blender verfügbaren Python-Funktionen verfügbar war. Diese wird aber benötigt, sodass SWIG daraus entsprechende \CS{}-Funktionen erzeugen kann. Über die Python-Funktion dir() hätte zwar ein geladenes Plugin über alle Typen und deren Funktionalitäten iterieren können, dies wäre aber weder effektiv noch zielführend gewesen. Zwar wäre dann nämlich die jeweilien Funktionen, nicht aber deren Parameter bekannt gewesen. Zur Lösung dieses Problems war ein erster Versuch, die im Blender-Quelltext (bzw. im Quelltext des Tools MakesRNA) vorhandenen Dateien zu parsen, da diese jegliche später in Python vorhandene Blender-Funktionalität in einer speziellen Syntax deklarieren. Ein erstes auf regulären Ausdrücken basiertes Tool zeigte allerdings Probleme bei andersartig deklarierten Strukturen, bspw. Enums. Alles in allem wäre diese Vorgehensweise zu aufwändig und zu fehleranfällig gewesen.

\subsubsection{MakesRNA}

Stattdessen wurde daher das in C geschriebene und zum Bau von Blender benötigte Tool MakesRNA genauer untersucht, da dieses die angesprochenen Dateien nicht nur oberflächlich parst, sondern direkt ausführt und so eine Reihe von weiteren Quelltext-Dateien erzeugt, die beim Bau von Blender Python um eben jene Funktionalität erweitert. Daraus ergaben sich zwei Erkenntnisse: Zum einen zeigte sich so, dass Python relativ simpel um eigene C++-Module erweitert werden kann (siehe ..., dies ist auch der Hauptzweck des MakesRNA-Tools) und zum anderen, dass ein Umbau des MakesRNA-Tools das gewünschte Ziel, nämlich eine Liste aller in Blender vorhandenen Python-Strukturen zu erzeugen, ermöglichen würde. Da dieses Tool aber Teil des kompletten Blender-Projekts ist und, wie eben erwähnt, benötigt wird, um Blender selbst zu bauen, wurde festgelegt, dass dieses Tool lediglich durch einen speziellen FUSEE-Modus erweitert werden soll, ohne dabei die eigentliche Funktionalität des Tools zu stören.

Die Idee war nun, mit Hilfe dieses Tools eine einzelne Header-Datei zu erzeugen, in der jegliche Blender-Klassen, -Methoden und Properties deklariert sind und die diese Aufrufe durch Einbindung der Python-Header-Datei und durch Aufrufe von Python-Funktionen wie \emph{PyGetAttribute} an Python und damit an Blender weiterreicht. So sollte also automatisiert ein C++-Wrapper für die Python-API erstellt werden. Im Folgenden nun zunächst eine Anleitung, um den Quelltext von Blender und damit auch den Quelltext von MakesRNA zu beziehen. Anschließend folgt dann eine nähere Erläuterung der für das Uniplug vorgenommenen Erweiterungen zur Erreichung dieser angestrebten Funktionalität

\paragraph{Bezug des Quelltextes}

Blender verwendet Git zur Versionierung seines Quelltextes. Allerdings werden zum Bau der Unterprojekte eine Vielzahl an externen Bibliotheken benötigt. Da diese mit einer Gesamtgröße von rund 10 Gigabyte nicht mit Git versioniert werden können, verwendet Blender zusätzlich zum eigenen Git-Server auch einen SVN-Server. Entsprechend komplex ist es, das Projekt und alle Abhängigkeiten korrekt zu beziehen. Hinzu kommt, dass anschließend mittels CMake zunächst die entsprechenden Projektdateien für den gewünschten Compiler erzeugt werden müssen. Um diesen kompletten Prozess zu vereinfachen, wurde daher zunächst ein Script erstellt, das alle benötigten Dateien herunterlädt und anschließend eine Solution für VisualStudio 2013 mittels CMake erzeugt. Des Weiteren wurden zwei Repositories auf GitHub angelegt. Das Repository \emph{blender} ist ein Fork vom offiziellen Blender-Repository inklusive aller Änderungen, die im Rahmen dieses Forschungsprojektes vorgenommen wurden. Dieses Repository ist als Submodule in das Repository \emph{MotherBase} eingebunden, das neben dem eben erwähnten Skript auch die benötigten Ordner und eine aktuelle Version von CMake bereitstellt.

Es sind daher nun nur noch wenige einfache Schritte notwendig, bevor Blender (und die Unterprojekte wie MakesRNA) gebaut werden können. Als erster Schritt muss ein Git- und ein SVN-Tool installiert werden und die Pfade zu diesen Tools müssen der Umgebungsvariable \emph{PATH} hinzugefügt werden. Anschließend kann das MotherBase-Repository bezogen und über den Befehl "./make.sh" aus der Git-Konsole heraus die "Installation" gestartet werden. Das Submodule "blender" wird selbstständig geupdated, ebenso werden mittels SVN alle notwendigen Abhängigkeiten heruntergeladen und anschließend über CMake die Solution erstellt. Dieser Prozess kann aufgrund der Größe der Dateien einige Zeit in Anspruch nehmen. Anschließend sollte im Ordner "cbuild" eine Blender.sln liege, die nun gebaut werden könnte. Zum regelmäßigen Aktualisieren des Forks stehen die beiden Dateien update1.sh und update2.sh zur Verfügung. Diese sollten in dieser Reihenfolge über die Git-Konsole ausgeführt werden. Da es zu Merge-Konflikten kommen könnte, ist der Updateprozess zweigeteilt. Nach Ausführen von update1.sh können so mögliche Konflikte behoben werden. Abschließend aktualisieren die Skripte automatisch die beiden Repositories und pushen die Änderungen selbstständig.

\paragraph{FUSEE-Modus im Projekt MakesRNA}

Innerhalb der Blender.sln befindet sich das Projekt "MakesRNA", wobei die für das Uniplug notwendigen Änderungen hauptsächlich an der Datei "makesrna.c" vorgenommen wurden. Hier wurden zwei neue Kommandozeilenparameter "--fusee" und "--nocomment" eingeführt, die das Tool in den FUSEE-Modus versetzen und so statt vielen verschiedenen für Blender notwendigen Dateien nur noch eine einzige Header-Datei erzeugt, die wie oben erwähnt die Python-Funktionalität wrapt. Diese Datei kann auch direkt von C++ aus(also unabhängig von FUSEE und Uniplug) verwendet werden. Daher handelt es sich hier bereits um eine vollständige C++-API für Blender, die all das ermöglicht, was auch in der Python-API möglich wäre.

Im Folgenden nun eine Übersicht über alle Unterschiede zun normalen Modus

\paragraph{Datentypen}

Da die von MakesRNA üblicherweise erstellen Dateien in C-Syntax geschrieben sind, werden im normalen Modus keine C++-Datentypen verwendet. Des Weiteren werden hier normalerweise mittels \#define-Direktive eigene Datentypen definiert, die spezielle Speichermechanismen implementieren. Da dies für Uniplug irrelevant ist und die Header-Datei C++-Syntax verwenden kann, wurden hier einige Änderungen an den Datentypen vorgenommen. In aller Regel werden Basistypen verwendet (int, bool, float) mit Ausnahme von Arrays und "Dictionaries". Für Arrays werden im normalen Modus in der Regel Pointer eingesetzt (bspw. zur Rückgabe von Array-Daten bei Funktionen). Da aber auf Pointer verzichtet werden sollte, um Speicherlecks zu vermeiden, war zunächst geplant, diese durch das in C++ bekannte std::array<> zu ersetzen. Da SWIG aber Probleme hat std::array zu übersetzen und im späteren Prozess daraus die von FUSEE bekannten Datentypen float2, float3, usw. generiert werden sollen, werden nun für alle möglichen Arrayarten (int-, float-, bool-Arrays mit Längen 1, 2, 3, etc.) eigene Datentypen im Stil "VFLOAT3" (entspricht std::array<float, 3>, bzw. float[3]) deklariert. Dazu werden im Vorfeld alle Properties und alle Parameter von Funktionen analysisiert und die entsprechend notwendigen Datentypen mittels \#define-Direktive zu Beginn der Header-Datei deklariert. Sie verfügen über ein "data"-Feld, das das eigentliche Array darstellt und über ein Operator-Overloading für den Subscript-Operator ([]), um mit der gewohnten Syntax auf die Daten des Arrays zuzugreifen. Dies hat auch zum Vorteil, dass in der gesamten Header-Datei weiterhin mit der gleichen Array-Syntax gearbeitet werden kann und lediglich die Datentypen durch die selbstdeklarierten Datentypen ersetzt werden müssen.

Maps: wurden in std::maps (bspw. std::maps<Objects>) geändert. Diese können von SWIG später in \CS{}-Dictionaries übersetzt werden. Dazu muss SWIG allerdings eine Liste an verwendeten std::maps zur Verfügung gestellt werden. Daher wird im FUSEE-Modus zusätzlich eine Interface-Datei für SWIG erstellt, in der alle std::maps-Typen aufgelistet sind.

Dynamische Arrays (teilweise Pointer) wurden in std::vector geändert. Diese kann SWIG in \CS{}-Listen übersetzen. Damit erfüllen sie sowohl in C++ als auch in \CS{} die Aufgabe eine dynamische Menge an Daten abspeichern zu können.

Ein weiter Sonderfall sind Enum-Typen.


\paragraph{Stukturen}

Deklarationen und Implementierungen: Alle Deklarationen (insbesondere also alle Klassen) sind in einer einzigen Datei deklariert. Im Folgneden eine Übersicht über gängige Programmierstrukturen und Ihre Implementierung im C++-Header-Datei.

\subparagraph{Klassen}

Es werden die meisten im MakesRNA-Tool definierten Klassen deklariert. Lediglich einige Basisklassen (bspw. die Klasse RNA\_Pointer), die nur für das interne Management zuständig sind, aber keine für den Nutzer relevante Funktionalität implementieren, werden ignoriert. Stattdessen wurde eine Basisklasse PyObjRef angelegt, die sich um Speicherung der Referenz und um das Speichermanagement kümmert. Die Rückgabewerte der Python-Funktionen (Pointer auf Objekte der Klasse PyObject) verweisen dabei auf Objekte, die anschließend weiter verarbeitet werden können (bei Sequenzen z.B. durch die Abfrage der einzelnen Items, die wiederum Pointer auf PyObject-Objekte sind). Je nach internem Python-Typ können diese auch in C-Typen konvertiert werden. Die Referenz auf diese Objekte wird in der Property pyobjref gespeichert.

Da Python ein Referenzzähler-System verwendet, um den Speicher der nicht mehr referenzierten PyObject-Objekte freizugeben, muss sich auch die Header-Datei um die korrekte Referenzzählung kümmern. Der Auffruf der Python-Funktionen erhöht in aller Regel den Referenzzähler für das zurückgegebene PyObject. Werden nun in der Header-Datei neue Objekte erzeugt, die jeweils auf das gleiche PyObject verweisen, müssen auch hier die Referenzzähler erhöht werden. SWIG bspw. verwendet bei der späteren Übersetzung allerdings nicht nur den Standardkonstruktor, sondern ruft ebenso sowohl den Kopierkonstruktor als auch den Zuweisungskonstruktor auf. Daher müssen alle drei Konstruktorarten in der Header-Datei explizit deklariert werden, sodass in allen drei Fällen auch der Referenzzähler des referenzierten Objektes erhöht wird. Da aber alle Klassen direkt oder indirekt von PyObjRef erben, ist es auchreichend, wenn diese Fuktionalität in der PyObjRef-Klasse implementiert ist. Ebenso ist in dieser Klasse ein Destruktor deklariert, der den Referenzzähler wieder verringert. Lediglich, wenn Python zu diesem Zeitpunkt nicht mehr intilaisiert ist (PyInitzialed ist dann null), also insbesondere wenn Blender gerade beendet wird, wird dieser Schritt übersrpungen, da es ansonsten zu Access-Violations käme. Der Speicher wird in diesem Fall so oder so gerade von Windows freigegeben.

\subparagraph{Properties}

Jegliche PRoperties liegen als Setter und Getter-Funktionen vor. Diese Getter-Funktionen geben den Aufruf an die Funktion PyGetAttr weiter, die ein PyObjekt und die abzufragende Property als String entgegentnimmt. Das Ergebnis ist wie oben bereits beschrieben ein weiterer Pointer auf ein PyObjekt. Dieses kann dann je nach Rückgabewert entweder in ein C++-Basityp konvertiert werden oder durch Aufruf der entsprechenden Konstrukturoren und durch Weitergabe der Referenz an die dadurch erzeugten Objekte auch in ein Objekt einer im Header-Datei deklarierten Klasse erzeugt werden. Bei den Settern wird entsprechend umgekehrt ein Basistyp oder ein Objekt angenommen und dieses zunächst in ein PyObjekt konvertiert und anschließend durch PyAttrSet wiederum mit Referenz und Property-Name als String an Python weitergereicht.

Da diese Konvertierungen und Aufrufe sich grundsätzlich über mehrere Zeilen erstrecken (bei Konvertierung in ein Array bis zu 8 Zeilen inkl. Speichermanagement) ergeben sich bei mehr als 1000 Klassen mit teilweise mehreren Dutzen Properties Unmengen an sich wiederholendem Code. Daher wurde hierfür und für die im folgenden Abschnitt beschriebenen Funktionen ein System aus \#define-Direktiven definiert, dass jegliche PRoperties auf eine Zeile reduziert und damit die Dateigröße stark reduziert. Die Namen der \#define-Direktiven wurde dabei so gewählt, dass deren Funktion sich direkt aus dem NAmen ergibt. So ergibt sich eine optimale Moschung aus Effizienz und Code-Verständlichkeit.

\subparagraph{Funktionen}

Funktionen stellen mitunter die größte Herausforderung dar. Dies hat mehrere Gründe. Zum einen können Funktionen in Python mehrere Rückgabewerte besitzen. Das MakesRNA-Tool markiert dazu ein oder mehrere Parameter der Funktion mit einem Out-Flag. Dieses Flag wird im FUSEE-Modus verwendet, um herausfinden, bei wie vielen und insbesondere bei welchen Parametern es sich eigentlich um Rückgabewerte handelt. Am einfachsten wäre es nun gewesen, diese Parameter beispielsweise als Call-By-Reference- oder Call-by-Pointer-Parameter zu definieren. Ein Nachteil wäre aber gewesen, dass Parameter, für die ein Defaultwert definiert ist, diesen nicht hötten..... Auch wäre die Verwendung in \CS{} möglicherweise komplexer gewesen. Daher wird im FUSEE-Modus entweder, wenn es sich nur um ein Rückgabewert handelt, dieser entsprechend als Return-Value definiert und der Parameter entfernt, oder aber, wenn es zwei oder mehr Rückgabewerte sind, automatisiert ein Struct angelegt, dass alle Rückgabewerte bündelt und die entsprechenden Parameter entfernt. So haben alle Funktionen nun tatsächlich nur noch Call-by-Value-Parameter und können entsprechend in \CS{} verwendet werden...

die Implementierung verwendet wie bei den Properties mehrere \#define-Direktiven, die... So müssen alle Parameter entsprechend umgewandelt werden (Arrays in PySequences, etc.), dann die Python-Funktion aufgerufen und alle Rückgabewerte wieder zurückgewandelt werden. Sind es mehrere, so wird das automatisch angelegte Struct mit Daten gefüllt und zurückgegeben. Wird das Objekt einer Klasse zurückgegeben, so wird das Objekt erzeugt und die Python-Referez übergebene. 

\subparagraph{Kommentare}

Das MakesRNA-Tool definiert bereits für viele Klassen, Properties, Funktionen, Enums, etc. Hilfstexte, die in Blender ... Im FUSEE-Modus werden diese Texte direkt als Kommentare an den entsprechenden Stellen in der Header-Datei verwendet. Diese sind direkt im javadooooo-Style, sodass mit Hilfe von Doxygen oder anderen Programmen eine Dokumentation für die Header-Datei erzeugt werden könnte. Da die Kommentare aber etwa 1 MB bei der Größe der Header-Datei ausmacht, können diese auch deaktiviert werden, dann MakesRNA mit dem Argument "--nocomment" gestartet wird.

\subsubsection{ManagedBridge}

Da Blender bzw. Python nur C++-Module laden kann, muss eine Brücke zum \CS{}-Plugin hergestellt werden, sodass von C++ aus auf \CS{}-Funktionalität zurückgegriffen werden kann. Dies kann unter Windows über ein Managed-C++-Plugin erreicht werden. Letztlich referenziert dieses lediglich das \CS{}-Plugin, ruft dessen Funktionen auf und exportiert die entsprechenden Funktionsaufrufe, sodass sie von C++ aus aufgerufen werden können.

\subsubsection{BlenderPlug}

Das Projekt BlenderPlug ist das eigentliche C++-Modul, das in Blender geladen werden kann und schließlich die Init-Funktion (oder andere Funktionen) bereitstellt, um über die ManagedBridge hinweg auf die \CS{}-Funktionalität zuzugreifen.  Daszu muss das Plugin 

In Blender selbst kann dann in der Python-Konsole über "from fusee import uniplug" und "uniplug.init()" die Funktion ausgeführt werden. Siehe dazu auch das beigelegte Tutorial zur Erstellung eines eigenen Plugins

\subsubsection{Aussicht}

Aktuell muss das Plugin noch manuell intialisiert werden. Es ist aber möglich, über ein direkt in Python geschriebenes Plugin, das unter dem Namen "\_\_init\_\_.py" ebensfalls in den Ordner Fusee gelegt wird, Uniplug entweder vollautomatisch auszuführen oder Kontextmenüeintäge anzulegen, über die das Uniplug ausgeführt werden kann. Mehr Informationen hierzu finden sich in der Blender-Doku (URL). Je nach Aufbau könnten so mehrere Plugins im Uniplug gebündelt werden (Exportfunktionalität, Szenenfunktionalität, etc.) oder ein Event-System (Aufruf einer speziellen Funktion beim Start vom Blender, Aufruf einer Funktion beim Beenden von Blender, etc.) aufbaut werden. Dies sollte in Zukunft ebenso weiter verfolgt werden wie die Entwicklung von Beispielplugins und insbesondere eines zur C4D-Variante des Uniplugs vergleichbaren Exportplugins, das es erlaubt die Szene als FUSEE-Web-Anwendung zu exportieren und so im Web anzuschauen.

Basierend auf den in 2.2.3 beschriebenen Kommentarsystem sollte eine Doku erstellt werden, die Uniplug beigelegt wird, sodass dem Nutzer die Entwicklung eigener Plugins vereinfacht wird, solange das eigentliche Uniplug, das die Schnittstellen vereinheitlichen soll, in Entwicklung ist. Ebenso wäre dies für Entwickler hilfreich, die abseits des Uniplugs die durch dieses Forschungsprojekt entstandene C++-API für Blender nutzen möchten.

Das System mehr an das C4D-Uniplug anpassen, so dass letztlich der Ordner nach \CS{}-Plugins durchsucht und per Reflection ausführt. Ebenso sollte die Nutzung auf anderen Betriebssystem vorbereitet werden, indem, wie es auch beim C4D-Uniplug möglich ist, Mono als Alternative zu nutzen, sollte die .NET-Runtime nicht zur Verfügung stehen. Das automatische Aufrufen von .NET-Funktionen aus einer C++-DLL heraus ist aktuell nur unter Windows möglich.

In \CS{} wäre es möglich für jegliche Properties sogenannte Auto-Setter und -Getter zu verwenden, sodass Anweisungen wie "pyUniplug.Context().Scene()...." zu "pyUniplug.Context.Scene..." vereinfacht werden können. Dies ist zwar hauptsächlich eine Aufgabe von SWIG, möglicherweise sind aber bereits Vorbereitungen in der C++-Header-Datei notwendig, sodass SWIG solche Auto-Setter und -Getter erstellen kann. Denkbar wäre bspw. das Anlegen von (in C++) ungenutzten "Dummy"-Feldern innerhalb der Klassen, sodass bei der Verarbeitung durch SWIG diese als Properties und nicht als Funktionen erkannt und um den Aufruf der eigentlichen Setter- und Getter-Funktionen (deren Access-Modifier im gleichen zu auf "private" geändert werden könnte) erweitert wird.

Zwangsläufig muss durch die längere Prozesskette von \CS{} über SWIG nach C++ nach Python ein Performanceverlust in Kauf genommen werden. Der Flaschenhals ist dabei aber weniger im Bereich SWIG zu erwarten, da Aufrufe von \CS{} in exportiere C/C++-Funktionen letzlich nur wenig Mehraufwand bedeuten, sondern im speziellen durch den Aufuruf von Python-Funktionen in der Header-Datei. Hier wird zusätzlich zu den Konvertierungen der PyObject-Objekte in Basistypen und umgekehrt auch immer wieder mit String-Operationen gearbeitet (siehe hierzu auch Abschnitt 2....). Insbesondere ist beim allerersten Initialisierungsaufruf des Uniplugs eine merkliche Verzögerung von 1 - 2 Sekunden messbar, da hier zunächst im Hintergrund die .NET-Runtime initialisiert werden muss. Weitere Aufrufe der in \CS{} implementierten Uniplug-Funktionen sind dann aber zumindest nicht merklich verzögert. Dennoch sollten hier einige präzise Messungen vorgenommen werden, um allgemeine Aussagen über den Performanceverlust zu treffen und so herauszufinden, ob diese im Alltag relevant sind. Es ist in der Regel zwar nicht davon auszugehen, dass mit FUSEE/Uniplug geschriebenen Plugins zeitkritische Aufgaben bearbeiten müssen, denkbar wäre es aber dennoch.  Auf Basis der sich dadurch ergebenden Erkenntnisse wären eventuell weitere Optimierungen (auch in Hinblick auf die Dateigröße) möglich (Cachen der Ergebnisse von Python-Funktionsaufrufen, etc.).