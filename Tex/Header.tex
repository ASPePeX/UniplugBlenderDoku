\mysubsection{Fabian Gärtner}{C++-API für Blender: die Header-Datei}\label{sec:header}

\subsubsection{Vorüberlegung}

Da Blender im Gegensatz zu 3D-Modellierungsprogrammen wie Cinema4D oder 3ds Max nur über eine Python-API, nicht aber über eine \CC-API verfügt, musste zunächst eine Möglichkeit gefunden werden, Blender dennoch mittels \CC{} anzusteuern. Zwar ist Blender quelloffen, sodass hier über Modifizierungen des Quelltexts pluginartige Erweiterungen vorgenommen werden könnten, dies hätte aber zur Folge, dass Nutzer des Uniplugs gezwungen wären, eine bestimmte Blender-Version zu verwenden oder gar Blender selbst zu bauen (siehe dazu den in Abschnitt \ref{sec:buildblender} beschriebenen Aufwand). Um diese Problematik zu vermeiden, wurden im Laufe des Projektes verschiedene Methoden evaluiert, mit denen von \CC aus die Python-API von Blender aufgerufen werden kann.

Eine der ersten Versuche bezogen sich dabei auf das Python-Modul \emph{ctypes}, das es erlaubt, in Python externe C- bzw. \CC-DLLs zu laden und die in den DLL implementierte Funktionalität auszuführen. Dies stellte sich allerdings schnell aus mehreren Gründen als ungeeignet für das Projekt heraus. Zum einen hätte das System hauptsächlich nur einseitig funktioniert, das heißt von Python aus hätten \CC-Funktionen aufgerufen werden können, aber keine Python-Funktionen von \CC{} aus. Einzig über Callbacks, die aber letztlich auch wieder von Python heraus gesetzt und aufgerufen werden müssen, wäre dies möglich gewesen. Zum anderen aber hätte bei jeder Kommunikation auch eine Typumwandlung stattfinden müssen, da ctypes mit speziellen Datentypen arbeitet, die nicht implizit in C-Datentypen konvertiert werden können.

Ein ganz allgemeines weiteres Problem war die Tatsache, dass zunächst keine Liste der Funktionen der Blender-API verfügbar war. Diese wird aber benötigt, damit SWIG daraus entsprechende \CS-Funktionen erzeugen kann. Über die Python-Funktion \emph{dir()} hätte zwar ein geladenes Plugin über alle Typen und deren Funktionalitäten iterieren können, dies wäre aber weder effektiv noch zielführend gewesen. Dann wären nämlich die jeweiligen Funktionen, nicht aber deren Parameter bzw. die Typen der Parameter bekannt gewesen. Zur Lösung dieses Problems beschäftigte sich ein erster Versuch damit, die im Blender-Quelltext (bzw. insbesondere im Quelltext des Tools \emph{MakesRNA}) vorhandenen Dateien zu parsen, da diese jegliche später in der Blender-API verfügbare Funktionalität in einer speziellen Syntax und durch Erweiterung von Python deklarieren. Listing \ref{lst:locdecl} zeigt dies beispielhaft anhand einer Property der Klasse \emph{Object}. Deklariert werden hier Typ, Beschreibung und andere Eigenschaften. Ein erstes auf regulären Ausdrücken basiertes Tool zeigte allerdings Probleme bei Strukturen, deren Deklaration von der Regel abwich. Alles in allem wäre diese Vorgehensweise daher zu aufwändig und zu fehleranfällig gewesen.

\begin{code}[caption={Deklaration der Property \protect\emph{location} der Klasse \protect\emph{Object} in \protect\emph{rna\_object.c}},label={lst:locdecl}]
	prop = RNA_def_property(srna, "location", PROP_FLOAT, PROP_TRANSLATION);
	RNA_def_property_float_sdna(prop, NULL, "loc");
	RNA_def_property_editable_array_func(prop, "rna_Object_location_editable");
	RNA_def_property_ui_text(prop, "Location", "Location of the object");
	RNA_def_property_ui_range(prop, -FLT_MAX, FLT_MAX, 1, RNA_TRANSLATION_PREC_DEFAULT);
	RNA_def_property_update(prop, NC_OBJECT | ND_TRANSFORM, "rna_Object_internal_update");
\end{code}

\subsubsection{MakesRNA}

Stattdessen wurde daher das in C geschriebene Tool MakesRNA genauer untersucht, da dieses die angesprochenen Dateien nicht nur oberflächlich parst, sondern direkt ausführt und so eine Reihe von weiteren Quelltext-Dateien erzeugt, die beim späteren Bau von Blender Python um eben jene Funktionalität erweitern. Daraus ergaben sich zwei Erkenntnisse: Zum einen zeigte sich so, dass Python relativ simpel um eigene \CC-Module erweitert werden kann\footnote{Siehe hierzu auch \url{https://docs.python.org/3.5/extending/index.html}} (dies ist auch der Hauptzweck des MakesRNA-Tools) und zum anderen, dass ein Umbau des MakesRNA-Tools das gewünschte Ziel, nämlich eine Liste aller in Blender vorhandenen API-Strukturen zu erzeugen, ermöglichen würde. Die Idee war daher, mit Hilfe dieses Tools eine \enquote{simple} Header-Datei zu erzeugen, in der jegliche Blender-API-Klassen, -Methoden, -Properties, etc. in \CC{} deklariert sind und die diese Aufrufe durch Einbindung der Python-Header-Datei mittels Python-Funktionen wie \emph{PyObject\_GetAttrString} oder \emph{PyObject\_CallMethod} an Python und damit an Blender weiterreicht. So sollte also, vereinfacht gesagt, bei Ausführung des Tools automatisiert ein \CC{}-Wrapper für die Blender-API erstellt werden. Da das MakesRNA-Tool aber Teil des kompletten Blender-Projekts ist und, wie eben erwähnt, benötigt wird, um Blender selbst zu bauen, wurde von der Forschungsgruppe festgelegt, dass dieses Tool lediglich durch einen speziellen FUSEE-Modus erweitert werden soll, ohne dabei die eigentliche Funktionalität des Tools im normalen Einsatz zu stören. 

Im Folgenden nun zunächst eine Anleitung, um den Quelltext von Blender und damit auch den Quelltext von MakesRNA zu beziehen. Anschließend folgt dann eine nähere Erläuterung der während des Forschungsprojekts vorgenommenen Erweiterungen zur Erreichung der angestrebten Funktionalität.

\paragraph{Bezug des Quelltextes}
\label{sec:buildblender}

Blender verwendet Git\footnote{\url{https://git.blender.org/gitweb/}} zur Versionierung seines Quelltextes. Allerdings werden zum Bau der Unterprojekte eine Vielzahl an externen Bibliotheken benötigt. Da diese mit einer Gesamtgröße von rund 10 Gigabyte nicht mit Git versioniert werden können, verwendet Blender zusätzlich zum eigenen Git-Server auch einen SVN-Server\footnote{\url{https://svn.blender.org/svnroot/bf-blender/trunk/}}. Entsprechend komplex ist es, das Projekt und alle Abhängigkeiten korrekt zu beziehen. Hinzu kommt, dass anschließend mittels CMake zunächst die entsprechenden Projektdateien für den gewünschten Compiler erzeugt werden müssen. Um diesen kompletten Prozess zu vereinfachen, wurde daher von der Forschungsgruppe zunächst ein einfaches Shell-Script erstellt, das alle benötigten Dateien herunterlädt und anschließend eine Solution für VisualStudio 2013 mittels CMake erzeugt. Des Weiteren wurden zwei Repositories auf GitHub angelegt. Das Repository \emph{blender}\footnote{\url{https://github.com/InformatischesQuartett/blender}} ist ein Fork vom offiziellen Repository inklusive aller Änderungen, die im Rahmen dieses Forschungsprojektes vorgenommen wurden. Dieses Repository ist als Submodule in das Repository \emph{MotherBase}\footnote{\url{https://github.com/InformatischesQuartett/MotherBase}} eingebunden, das neben dem eben erwähnten Skript auch die benötigten Ordner und eine aktuelle Version von CMake bereitstellt.

Es sind daher nun nur noch wenige einfache Schritte notwendig, bevor Blender (und die Unterprojekte wie MakesRNA) gebaut werden kann beziehungsweise können. Als erster Schritt muss ein Git- und ein SVN-Tool installiert werden und die Pfade zu diesen Tools müssen der Umgebungsvariablen \emph{PATH} hinzugefügt werden. Anschließend kann das MotherBase-Repository bezogen und über den Befehl \emph{./make.sh} aus der Git-Konsole heraus die \enquote{Installation} gestartet werden. Das Submodule blender wird selbstständig geupdated, ebenso werden mittels SVN alle notwendigen Abhängigkeiten heruntergeladen oder aktualisiert und anschließend über CMake die Solution erstellt. Dieser Prozess kann aufgrund der Größe der Dateien einige Zeit in Anspruch nehmen. Anschließend sollte im Ordner \emph{cbuild} die Solution \emph{Blender.sln} liegen, die nun als x64-Release gebaut werden könnte. Zum regelmäßigen Aktualisieren des Forks stehen die beiden Dateien \emph{update1.sh} und \emph{update2.sh} zur Verfügung. Diese sollten in dieser Reihenfolge über die Git-Konsole ausgeführt werden. Da es zu Merge-Konflikten kommen könnte, ist der Updateprozess zweigeteilt. Nach Ausführen von update1.sh können so erst mögliche Konflikte behoben werden und anschließend das Update fortgesetzt werden. Abschließend aktualisieren die Skripte automatisch die beiden Repositories und pushen die Änderungen selbstständig mit Datumsangabe in der Commit-Message.

\paragraph{FUSEE-Modus im Projekt MakesRNA}

Innerhalb der Blender.sln befindet sich das Projekt MakesRNA, wobei die für das Forschungsprojekt notwendigen Änderungen hauptsächlich an der Datei \emph{makesrna.c} vorgenommen wurden. Hier wurden zwei neue Kommandozeilenparameter \emph{-{}-fusee} und \emph{-{}-nocomment} eingeführt, die das Tool in den FUSEE-Modus versetzen. Alle relevanten Funktionen im Quelltext des MakesRNA-Projektes fragen den aktuellen Modus ab und erzeugen so ggf. statt den vielen verschiedenen für Blender notwendigen Dateien nur noch eine einzige Header-Datei, die wie oben erwähnt die Blender-API wrappt. Diese Datei kann auch direkt von \CC{} aus (also unabhängig von FUSEE und Uniplug) verwendet werden. Daher handelt es sich hier bereits um eine vollständige \CC-API für Blender, die all das ermöglicht, was auch aus Python mittels Blender-API möglich wäre.

Im Folgenden nun eine genauere Übersicht über alle Unterschiede und vorgenommen Änderungen an Datentypen, Funktionen, etc. im Vergleich zum normalen Modus des MakesRNA-Tools.

\paragraph{Datentypen}

Da die von MakesRNA üblicherweise erstellen Dateien in C-Syntax geschrieben sind, werden im normalen Modus keine \CC-Datentypen verwendet. Des Weiteren werden hier normalerweise mittels \#define-Direktiven eigene Datentypen definiert, die spezielle Speichermechanismen implementieren. Da dies für dieses Forschungsprojekt und für das Uniplug irrelevant ist und die Header-Datei im Vergleich zu C modernere \CC-Syntax verwenden kann, wurden Änderungen an den Datentypen vorgenommen. In aller Regel werden Basistypen verwendet (\emph{int, bool, float}) mit Ausnahme von Arrays, \emph{Collections} und Strings in Form von \emph{char}-Pointern. Letztere wurden durch \emph{std::strings} ersetzt. Für Arrays werden im normalen Modus in der Regel Pointer eingesetzt (bspw. zur Rückgabe von Array-Daten bei Funktionen). Da aber auf Pointer verzichtet werden sollte, um Speicherlecks zu vermeiden, war zunächst geplant, diese durch das in \CC{} bekannte \emph{std::array<>} zu ersetzen. SWIG hat allerdings Probleme std::array (und im allgemeinen Nicht-POD-Strukturen) korrekt nach \CS{} zu übersetzen und im späteren Prozess daraus die von FUSEE bekannten Datentypen \emph{float2, float3}, usw. zu generieren. Daher deklariert das MakesRNA-Tool für alle möglichen Array-Arten (int-, float-, bool-Arrays mit Längen 1, 2, 3, etc.) eigene Datentypen im Stil \emph{VFLOAT3} (entspricht \emph{std::array<float, 3>}, bzw. \emph{float[3]} bzw. \emph{float3}). Dazu werden im Vorfeld alle Properties und alle Parameter von Funktionen analysiert und die entsprechend notwendigen Datentypen mittels \#define-Direktive zu Beginn der Header-Datei deklariert. Siehe dazu Listing~\ref{lst:vfloat}. Die entsprechenden Structs verfügen über ein \emph{data}-Feld, das das eigentliche Array darstellt und über Operator-Overloading für den Subscript-Operator ([ ]), um mit der gewohnten Syntax auf die Daten des Arrays zuzugreifen. Dies hat auch zum Vorteil, dass in der gesamten Header-Datei weiterhin mit der gewohnten Array-Syntax gearbeitet werden kann und lediglich die Datentypen durch die selbstdeklarierten Datentypen ersetzt werden mussten. Der Name diese Datentypen weist den Nutzer dabei gleichzeitig auf die Anzahl an gespeicherten Werten hin, was insbesondere dadurch relevant ist, dass noch nicht für alle Vector-Datentypen ein entsprechendes FUSEE-Äquivalent existiert. Die beiden Funktionen \emph{get\_value} und \emph{set\_value} sind hauptsächlich für die spätere Übersetzung nach \CS{} gedacht, wo diese dann vom in \CS{} definierten Subscript-Operator aufgerufen werden.

\begin{code}[caption={Deklaration der Vektordatentypen mittels \protect\#define},label={lst:vfloat}]
#define DEFINE_VECTOR_POD(sname, stype, slength)\
	struct V##sname##slength {\
	private:
		stype data[slength];\
	public:\
		stype get_value(const int idx) { return data[idx]; }\
		void set_value(const int idx, stype value) { data[idx] = value; }\
		stype& operator[] (const int idx) {return data[idx];}\
	};

DEFINE_VECTOR_POD(FLOAT, float, 2);  // etc.
\end{code}

Dynamische Arrays (teilweise Pointer) wurden in \emph{std::vector<>} geändert. Diese kann SWIG selbstständig in \CS{}-Listen übersetzen. Damit erfüllen sie sowohl in \CC{} als auch in \CS{} die Aufgabe, eine dynamische Menge an Daten abspeichern zu können. Collections hingegen (in der Blender-API Ansammlungen von Key-Value-Paaren mit eigenem Speichermanagement) wurden in \mbox{\emph{std::maps<string, *>}} geändert. Diese können von SWIG später in \CS{}-Dictionaries übersetzt werden, sodass bspw. Objekte in der 3D-Szene durch ihren Namen abgefragt werden können. Dazu muss SWIG allerdings eine Liste an verwendeten Key-Value-Paaren zur Verfügung gestellt werden. Daher wird im FUSEE-Modus zusätzlich eine Interface-Datei für SWIG erstellt, in der alle std::maps-Typen aufgelistet sind.

Ein weiter Sonderfall sind Enum-Typen. Da Python bzw. die Blender-API Enum-Werte nur in Form von Strings zurückliefert und entsprechend Strings bei der Zuweisung von Enum-Typ-Variablen erwartet, dies aber für Programmierer natürlich ein Problem darstellt, werden in der Header-Datei Konvertierungsfunktionen, die Enum-Werte in Strings und Strings in Enum-Werte konvertieren, deklariert. Ein Beispiel für solche Konvertierungen ist in Listing \ref{lst:enumconv} zu finden. Hier werden zwei std::maps angelegt, die jeweils entweder ein String annehmen und ein int zurückliefern oder umgekehrt ein int annehmen und einen entsprechenden String zurückliefern. Dass diese Funktionen einen numerischen Wert und nicht gleich einen Enum-Typ zurückliefern, liegt am Template-Prinzip, das der std::maps-Klasse zugrunde liegt. Der Compiler legt zur Compilezeit für jedes std::map der Form \emph{std::map<std::string, example\_enum>} eine konkrete Klasse an. Dies heißt zwangsläufig, dass für jeden neuen Enum-Typ eine solche Klasse angelegt werden müsste (und zwar jeweils einen für die Hin- und Rücktransformation). Bei ersten Tests endete dies in Compilezeiten von mehreren Minuten, teilweise auch in Speicherüberläufen. Daher wird nun stattdessen immer nur std::string und int als Key-Value-Paare verwendet und durch implizites und explizites casten (letzteres mit \emph{static\_cast<example\_enum> enum\_valu}e) bei Bedarf der entsprechende Enum-Typ erzeugt. 

\begin{code}[caption={Konvertierung von Enum-Typen in Strings und umgekehrt},label={lst:enumconv}]
 		std::map<std::string, int> create_string_to_smoked_type_items() {
			return { { "SMOKEDENSITY", smoked_type_items_SMOKEDENSITY }, /* ... */ };
		};

		std::map<int, std::string> create_smoked_type_items_to_string() {
			return { { smoked_type_items_SMOKEDENSITY, "SMOKEDENSITY" }, /* ... */ } };
		};

		std::map<std::string, int> string_to_smoked_type_items = create_string_to_smoked_type_items();
		std::map<int, std::string> smoked_type_items_to_string = create_smoked_type_items_to_string();
\end{code}

Damit nun nicht bei jeder einzelnen Übersetzung wiederum die Map neu erzeugt werden muss, wurden die entsprechenden Variablen als Klassenattribute angelegt und eine entsprechende Map-Erzeugungsfunktion implementiert, sodass diese Maps beim Erzeugen der Klasse erstellt werden. Schön wäre es hier zwar gewesen, die Attribute als \emph{static-const}-Variablen zu deklarieren, da sie dann zum einen nach der Initialisierung nicht mehr geändert werden könnten und zum anderen klassen- statt objektspezifisch wären, dies ist aber in der jetzigen Form nicht möglich. Zum einen darf der \CC{}-Compiler laut den Spezifikationen keinen impliziten Copy- und Zuweisungs-Konstruktor anlegen, wenn nicht-statische Variablen als \emph{const} deklariert wurden. Beim Erzeugen von Objekten werden die Werte aller Variablen des alten Objektes in die des neuen kopiert. Da dies bei Konstanten logischerweise nicht geht, werden in einem solchen Fall implizite Konstruktoren aus der Klasse entfernt. Zum anderen handelt es sich bei std::maps nicht um Basistypen. Daher sind diese Felder aktuell lediglich als gewöhnliche Felder angelegt.

\paragraph{Stukturen}

Sowohl die Deklarationen als auch die Implementierungen werden in der Header-Datei vorgenommen. Sofern dies nicht anders notwendig ist (bspw. bei Abhängigkeiten zu anderen Klassen), erfolgt die Implementierung zeitgleich zur Deklaration. Im Folgenden nun eine Übersicht über gängige Programmierstrukturen und ihre Implementierung in der \CC-Header-Datei mittels MakesRNA.

\subparagraph{Klassen}

Die meisten der im MakesRNA-Tool definierten Klassen werden deklariert. Die Idee hinter diesem System ist, dass bei Erzeugung eines Python-Objektes durch Aufruf einer entsprechenden Blender-API-Funktion gleichzeitig auch ein Objekt einer äquivalenten \CC-Klasse erzeugt wird, das auf das Python-Objekt verweist und Funktionsaufrufe delegiert. Lediglich einige Basisklassen (bspw. die Klasse RNA\_Pointer), die nur für das interne Management zuständig sind, aber keine für den Nutzer relevante Funktionalität implementieren, werden ignoriert. Stattdessen wurde eine gemeinsame Basisklasse \emph{pyObjRef} angelegt, die sich um Speicherung der Referenz und um das Speichermanagement kümmert. Python-Funktionen geben in aller Regel Pointer auf Objekte der Klasse \emph{PyObject} zurück, die anschließend weiter verarbeitet werden können (bei Sequenzen z.B. durch die Abfrage der einzelnen Items, die wiederum Pointer auf PyObject-Objekte sind). Je nach internem Python-Typ können diese auch in C-Basistypen konvertiert werden. Der Pointer auf diese Objekte wird in der Property \emph{pyobjref} gespeichert, sodass jede \CC-Klasse auf ihr aktives Äquivalent in Python verweisen kann. Da Python ein Referenzzähler-System verwendet, um den Speicher der nicht mehr referenzierten PyObject-Objekte freizugeben, muss sich auch die Header-Datei um die korrekte Referenzzählung kümmern. Der Aufruf der Python-Funktionen erhöht in der Regel den Referenzzähler für das zurückgegebene PyObject. Werden nun in der Header-Datei neue Objekte erzeugt, die jeweils das gleiche PyObject referenzieren, müssen auch hier die Referenzzähler erhöht werden. SWIG bspw. verwendet bei der späteren Übersetzung nicht nur den Standardkonstruktor, sondern ruft ebenso sowohl den Kopierkonstruktor als auch den Zuweisungskonstruktor auf. Daher müssen alle drei Konstruktorarten in der Header-Datei explizit deklariert werden, sodass in allen drei Fällen auch der Referenzzähler des referenzierten Objektes erhöht wird. Da aber alle Klassen direkt oder indirekt von pyObjRef erben, ist es ausreichend, wenn diese Fuktionalität in der pyObjRef-Klasse implementiert ist. Ebenso ist in dieser Klasse ein Destruktor deklariert, der den Referenzzähler bei Bedarf verringert. Lediglich, wenn Python zu diesem Zeitpunkt nicht mehr initialisiert ist (PyInitialized ist dann \emph{null}), also insbesondere wenn Blender gerade beendet wird, wird dieser Schritt übersprungen, da es ansonsten zu Access-Violations käme. Der Speicher wird in diesem Fall sowieso gerade durch Windows freigegeben.

Zudem wird in der Header-Datei eine zusätzliche Klasse \emph{pyUniplug} implementiert, die den Einstiegspunkt zur Verwendung der Blender-\CC-API definiert. Hier wird im Konstruktor das Blender-Python-Modul geladen und die Referenz darauf gespeichert. Die Funktion \emph{context} liefert dann ein \emph{Context}-Objekt zurück, über das auf jegliche Blender-API-Funktionalität zugegriffen werden kann. Dieses Verhalten entspricht dem aus der Blender-Python-Konsole bekannten \emph{from bpy import *} und \emph{bpy.context.*}. Abkürzungen zu Subtypen wie \emph{context().scene()} könnten hier ebenfalls deklariert werden. Des Weiteren steht in der pyUniplug-Klasse eine \emph{print}-Funktion zur Verfügung, die die mittels String-Parameter übergebene Nachricht als print-Befehl an \emph{PyRun\_SimpleString} weitergibt und so ein Debugging aus \CC oder \CS ermöglicht. 

\subparagraph{Properties}

Properties liegen als Setter- und Getter-Funktionen vor. Die Getter-Funktionen geben den Aufruf an die Funktion \emph{PyObject\_GetAttrString} weiter, die einen Pointer auf ein PyObjekt und die abzufragende Property als String entgegennimmt. Das Ergebnis ist wie bereits beschrieben wiederum ein Pointer auf ein PyObjekt. Dieses kann dann je nach Rückgabewert entweder in einen \CC-Basistyp oder durch Aufruf der entsprechenden Konstruktoren und durch Weitergabe der Referenz an die dadurch erzeugten Objekte in ein Objekt einer in der Header-Datei deklarierten Klasse konvertiert werden. Bei den Settern wird entsprechend umgekehrt ein Basistyp oder ein Objekt angenommen und dieses zunächst in ein PyObject konvertiert und anschließend durch die Funktion \emph{PyObject\_SetAttrString} wiederum mit Referenz und Property-Name als String an Python weitergereicht.

Da diese Konvertierungen und Aufrufe sich grundsätzlich über mehrere Zeilen erstrecken (bei Konvertierung in ein Array bis zu acht Zeilen inkl. Speichermanagement) ergeben sich bei mehr als 1000 Klassen mit teilweise mehreren dutzend Properties Unmengen an sich wiederholendem Code. Daher wurde hierfür und für die im folgenden Abschnitt beschriebenen Funktionen ein System aus \#define-Direktiven definiert (siehe Listing~\ref{lst:getdef}), das die Implementierung jeglicher Getter- bzw. Setter-Funktionen auf eine Zeile (siehe Listing~\ref{lst:getimp}) und damit die Dateigröße stark reduziert. Die Namen der \#define-Direktiven wurde dabei so gewählt, dass deren Funktion direkt aus dem Namen geschlossen werden kann. So ergibt sich eine optimale Mischung aus Effizienz und Code-Verständlichkeit.

\begin{code}[caption={Beispiel für die Vereinfachung durch \#define-Direktiven},label={lst:getdef}]
#define PRIMITIVE_TYPES_GETTER(stype, sconv, sidentifier)\
	PyObject *val = PyObject_GetAttrString(pyobjref, sidentifier);\
	stype resval = sconv;\
	Py_CLEAR(val);\
	return resval;
\end{code}

\begin{code}[caption={Beispiel für die Implementierung einer Getter-Funktion},label={lst:getimp}]
int queue_count() {
	PRIMITIVE_TYPES_GETTER(int, PyLong_AsLong(val),                 "queue_count")
}
\end{code}

\subparagraph{Funktionen}

Funktionen stellten mitunter die größte Herausforderung dar. Dies hat mehrere Gründe. Zum einen können Funktionen in Python mehrere Rückgabewerte besitzen. Das MakesRNA-Tool markiert dazu ein oder mehrere Parameter der Funktion mit einem speziellen Ausgabe-Flag. Dieses Flag wird im FUSEE-Modus verwendet, um herausfinden, bei wie vielen und insbesondere bei welchen Parametern es sich eigentlich um Rückgabewerte handelt. Am einfachsten wäre es nun gewesen, diese Parameter beispielsweise als Call-By-Reference- oder Call-by-Pointer-Parameter zu definieren. Dies hätte aber zu Problemen bei Parametern mit Default-Werten geführt, da diese am Ende der Parameterdeklaration stehen müssen. Auch wäre die Verwendung in \CS{} möglicherweise komplexer gewesen. Daher wird im FUSEE-Modus entweder, wenn es sich nur um ein Rückgabewert handelt und die Funktion selbst als \emph{void}-Funktion deklariert ist, dieser entsprechend als Return-Value definiert und der Parameter entfernt, oder aber, wenn es zwei oder mehr Rückgabewerte sind, automatisiert ein Struct angelegt, das alle Rückgabewerte bündelt und die entsprechenden Parameter entfernt. Es werden zudem nur Value-Typen, und nicht wie ursprünglich bei MakesRNA Pointer, auf Objekte verwendet und zurückgegeben. Dies vereinfacht das Speichermanagement vor allem in Hinblick darauf, dass diese Funktionen später in \CS verwendet werden sollen. Daher haben alle Funktionen nur noch Call-by-Value-Parameter und Value-Typen als Rückgabewerte und können entsprechend benutzerfreundlich verwendet werden. 

Ein weiteres Problem bei der Implementierung der Funktionen ist, dass jegliche Parameter (Basistypen, Array, Objekte, etc.) und später auch jegliche Rückgabewerte in PyObject-Objekte bzw. wiederum zurück in Basistypen oder andere Objekte konvertiert werden müssen. Existieren mehrere Rückgabewerte, so wird das automatisch angelegte Struct mit den konvertierten Daten gefüllt und zurückgegeben. Wird das Objekt einer Klasse zurückgegeben, so wird das entsprechende Objekt erzeugt und der Pointer auf das PyObject gespeichert. Da dies teilweise zu sehr langen Implementierungen führt, wird, wie bei den Properties im letzten Abschnitt beschrieben, mittels \#define-Direktiven die redundanten Code-Teile gebündelt. Damit kann die Implementierung von Funktionen auf wenige Zeilen gekürzt werden.

Die Implementierung der Funktionen erfolgt, wenn möglich, direkt bei der Deklaration innerhalb der Klassendeklaration. Verwendet eine Funktion allerdings ein Objekt einer Klasse, die zu diesem Zeitpunkt noch nicht deklariert wurde, erfolgt die Implementierung erst nach der Deklaration aller Klassen. Das MakesRNA-Tool entscheidet dynamisch, wann dies notwendig ist und wann nicht. Auch hierdurch wird die Dateigröße optimiert.
 
\subparagraph{Kommentare}
\label{sec:comments}

Das MakesRNA-Tool definiert bereits für viele Klassen, Properties, Funktionen, Enums, etc. Hilfstexte, die in Blender als Tooltips in der GUI oder für die Doku der Blender-API\footnote{\url{https://www.blender.org/api/blender_python_api_2_75_3/}} verwendet werden. Im FUSEE-Modus werden diese Texte direkt als Kommentare an den entsprechenden Stellen in der Header-Datei verwendet. Diese sind im \emph{javadoc}-Stil\footnote{\url{http://www.oracle.com/technetwork/articles/java/index-jsp-135444.html}} angelegt, sodass mit Hilfe von \emph{Doxygen} oder anderen Programmen eine umfangreiche Dokumentation für die Header-Datei erzeugt werden könnte. Dies kann die Entwicklung eines Plugins in \CS als auch eines \CC-Plugins vereinfachen. Da die Kommentare aber etwa 1 MB bei der Gesamtgröße der Header-Datei ausmachen, können diese auch deaktiviert werden, indem MakesRNA mit dem Argument \emph{-{}-nocomment} gestartet wird.

\newpage