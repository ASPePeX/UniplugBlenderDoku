\mysubsection{Linda Schey, Sarah Häfele}{Swig}\label{sec:SWIG}

Swig\footnote{\url{http://swig.org/}} ist ein Programmierwerkzeug, das es ermöglicht in C/\CC~geschriebenen Programmcode durch andere Programmiersprachen anzusprechen. Da \CS von Swig neben vielen anderen Programmier- und Skriptsprachen unterstützt wird, eignete es sich somit auch um in \CC~geschrieben Programmcode mit FUSEE zu verbinden. Swig wurde gewählt, da es zum einen bereits in dem in einem früheren Projekt für FUSEE entwickelten Cinemea4D-Uniplug verwendet wurde und zum anderen die Arbeit abnimmt, einen kompletten Wrapper von Hand schreiben zu müssen, da man sich mittels Swig einen Wrapper generieren lassen kann. Zudem erleichtert es die Wartung von Projekten, da Updates im \CC-Code nicht von Hand eingetragen werden müssen, sondern lediglich für die neue Generierung des Wrappers die aktuellen Header-Dateien eingebunden werden müssen. Um besondere Datentypen zu übersetzen, die beispielsweise in den Standard APIs von \CC und \CS nicht vorhanden sind oder in einen anderen (optimierten) Datentyp umgewandelt werden sollen, müssen für diese in einem Swig-Interface File extra Vorschriften definiert werden.
Um den Wrapper zu generieren, muss zusätzlich die Python Library eingebunden werden, da die Header-Datei teilweise Python Klassen verwendet. Außerdem wird die Fusee.Math Library referenziert, da einige Datentypen auf Fusee-Datentypen gemappt werden.

\subsubsection{Überblick}
Swig ist nicht intuitiv verwendbar. Bei der Nutzung ist einiges zu beachten, was durch die Swig-Dokumentation nicht gleich ersichtlich ist und erst durch Trial-and-Error langsam erarbeitet werden kann (hier spielt zudem noch das Zusammentreffen von Blender und FUSEE mit all ihren Eigenheiten eine wichtige Rolle, wie später noch besser ersichtlich wird). Deshalb zunächst eine Liste mit Dingen, auf die beim Entwickeln mit Swig zu achten ist und auf deren Inhalt zum Teil später noch näher eingegangen wird.

\begin{itemize}
%\item Den Build der Solution sowie deren Unterprojekte auf \textbf{Release} stellen: Da Blender Python \textcolor{red}{als Kommunikationssprache verwendet und Python ...} muss das Projekt als Release gebaut werden, da sonst \textcolor{red}{?????????} Näheres zu den Buildeinstellungen in \textcolor{red}{...}-> kann glaub weg
\item Die richtige \textbf{Build-Reihenfolge} ist unbedingt zu beachten. Zudem sollten zuvor \emph{geswiggte} Klassen aus dem Ordner gelöscht werden, wenn an ihnen Änderungen vorgenommen wurden, um Fehler durch alte Dateien zu vermeiden. Auf die Reihenfolge soll später näher eingegangen werden (siehe Abschnitt \ref{subsubsec:Aufbau}).
%\item \textcolor{red}{BigObj: wieso, weshalb, warum} -> brauchne wir nicht mehr
\item \textbf{Größe der Header-Datei:} Aus Sichtweise der Swig-Entwickler sind einzelne Header-Dateien pro Klassen besser zu swiggen als eine große Datei mit allen gesammelten Klassen. Das Swiggen dauert mit einem großen File dementsprechend lang. Tritt ein Fehler auf muss der ganze Prozess wiederholt werden. Fehler beim Swiggen werden so erst am Ende erkannt. %Zudem vermuten das Swig-Team dieses Projektes, dass weitere Komplikationen durch das zu großes File aufgetreten sind. 
\item Die \textbf{Unterschiede zwischen \CC und \CS} müssen verstanden und beachtet werden, da Swig nicht alle Klassen, Methoden, etc. einfach in die andere Sprache übersetzen kann. Hierzu zählen sicherlich 
	\begin{itemize}
	\item \textbf{Speicher Allokation und Pointer:}
	Da die Anwendung \CC - in \CS -Code umwandeln soll, können Fehler bei der Speicherbelegung auftreten. Um dies so weit als möglich ausschließen zu können, wurde auf die Verwendung von Pointern verzichtet.
	\item \textbf{Garbage Collector:} Durch den Managed Code in \CS können eventuell Probleme auftreten. Im unmanaged \CC -Code sind keine Vorbereitungen für einen eventuellen Garbage Collector getroffen. Wird dieser Code mit SWIG nach \CS übersetzt, kann es Probleme bei Dependencies geben, dann nämlich, wenn der Garbage Collector ein Objekt entfernt, auf das ein anderes zugreifen möchte. Hier kann es zu Programmabstürzen kommen.
	\item \textbf{Default Werte:} \CC und \CS gehen unterschiedlich mit Default-Werten um, wenn eine Variable nicht initialisiert wurde. Bei \CC ist kein Default-Wert spezifiziert, sodass der Wert von der Implementierung und Laufzeit abhängt. \CS vergibt dagegen immer einen Default-Wert. Dies ist wiederum bei der Übersetzung mit Swig zu beachten. Dieses Problem entstand beim Übersetzten von Klassen, die nicht dem Schema eines PODs entsprechen (vgl. Abschnitt \ref{besonderedatentypen}).
	%\item \textbf{Pointer:} Da die Anwendung \CC - in \CS -Code umwandeln soll, treten hier verhäuft Fehler und Komplikationen auf. In Unterkapitel \ref{subsubsec:Datentypen} soll dies eingehend behandelt werden. ich glaub das kann dann weg
	\end{itemize}
\item Spezialfälle werden in der Swig-Doku nicht ausreichend behandelt, weswegen die Entwickler durch sogenannte \textbf{Mailing Lists} kontaktiert wurden. Der Dialog mit den Spezialisten brachte neue Erkenntnisse, konnte jedoch nicht alle Spezialfälle klären. %Hierzu später ebenfalls mehr.
%\item \textbf{Syntax:} Syntaxunterschiede können ebenfalls Komplikationen hervorrufen. Da Swig hauptsächlich Strings ersetzt, muss die Struktur der jeweiligen Syntax immer beachtet werden. So muss zum Beispiel in \CC der Zeigerstern (*) direkt vor dem Variablennamen stehen, wobei in \CS dieser zur Typendeklaration gehört. \textcolor{red}{??? Linda: ja da weiß ich auch noch nciht od das wirklich relevant is oder was da dann rein soll}
\item \textbf{Debuggen mit Swig:} Da es kein Syntax-Highlighting für SWIG in Visual Studio gibt, ist das Finden von Fehlern im Swig-Code nicht leicht. Hierzu hat sich das Anhängen von aussagekräftigen Inline-Kommentaren direkt hinter der zu ersetzenden Swig-Variablen als nützlich erwiesen. Der Kommentar wird so in den erzeugten Code mit eingebaut und es kann explizit danach gesucht werden, um Fehler nachzuverfolgen.
\end{itemize}

\subsubsection{Aufbau des Projektes in VS}\label{subsubsec:Aufbau}

Um die \CC~Header-Datei nach \CS~zu wrappen wurde eine Solution aufgesetzt, die aus fünf Projekten besteht und den \CC~Code nach \CS~wrappt. Im Folgenden werden diese Projekte in der Reihenfolge, in der sie für eine erfolgreiche Generierung des \CS~Codes gebaut werden müssen, erläutert.\\

\begin{description}
\item[CppApi]\hfill \\
Enthält die \CC~Header-Datei mit allen Klassen und Funktionen. Generiert \emph{CppApi.dll}.
\item[SWIG]\hfill \\
Enthält drei Swig-Interfaces (\emph{CppApi.i, POD\_Mapping.i und \\
uniplug\_blender\_api\_swig.i}) nach deren Vorschriften besondere Datentypen geswiggt werden (mehr dazu in Abschnitt \ref{subsubsec:swiginterface}). Anhand der Header-Datei werden die entsprechenden Wrapper in \CS generiert. Diese werden dem \emph{CsWrapper}-Projekt hinzugefügt.
\item[CppWrapper]\hfill \\
Enthält das \CC~ File CppApiWrapper.cpp, das ebenfalls durch Swig generiert wird. Es stellt die Schnittstelle zwischen dem \CC~ Code und dem \CS~ Code dar, unter Berücksichtigung der durch Swig gemarschallten Typen und deren Umwandlungen. Des Weiteren wird die \emph{CppWrapper.dll} generiert.
\item[CsWrapper]\hfill \\
Generiert CsWrapper.dll, die die aus dem SWIG-Projekt generierten \CS~Klassen enthält. 
\item[CsClient]\hfill \\
Dieses Projekt ist das Plugin, das der Entwickler schreiben kann. Hier wird die Init-Funktion von \CS aus nach Blender aufgerufen. Im vorliegenden Projekt liegt hier ein einfaches Beispiel-Plugin vor.
\item[ManagedBridge]\hfill \\ 
Brücke zwischen dem \CS-Plugin und dem \CC-Plugin für Blender. Es handelt sich dabei um ein Managed-\CC-Projekt, das das \CS-Plugin referenziert, dessen Funktionen aufruft und die entsprechenden Funktionsaufrufe exportiert, sodass diese von \CC aus aufgerufen werden können.
\item[BlenderPlug]\hfill \\ 
Das Projekt BlenderPlug ist das eigentliche \CC-Modul, das in Blender als Python-Erweiterungs-Modul geladen werden kann und eine Init-Funktion bereitstellt, um über die ManagedBridge hinweg auf die \CS{}-Funktionalität zuzugreifen. Der relativ kurze \CC-Quelltext dieses Programms richtet sich nach den Vorgaben von Python\footnote{\url{https://docs.python.org/3/extending/extending.html}} und muss mittels Python-Compiler kompiliert werden. Ein entsprechendes Script und eine entsprechende Konfigurationsdatei (\emph{setup.py}) werden im Post-Build-Prozess aufgerufen. Die daraus entstehende pyd-Datei (letztlich eine \CC-DLL) wird dann zusammen mit allen anderen Projektdateien in den Unterordner \emph{Fusee} im Addon-Ordner im Blender-Hauptverzeichnis und in das Blender-Hauptverzeichnis selbst kopiert. In Blender kann dann in der Python-Konsole über \emph{from fusee import uniplug} und \emph{uniplug.init()} die Init-Funktion ausgeführt werden. Siehe hierzu auch das angehängte Tutorial zur Erstellung eines eigenen Plugins.
\end{description}

\subsubsection{Swig-Interface Files}\label{subsubsec:swiginterface}
Da in diesem Projekt mit Blender- bzw. FUSEE spezifischen Datentypen gearbeitet wird, die weder in der Standard \CC noch in der\CS API vorkommen, müssen diese im Swig-Interface behandelt werden. Neben diesen besonderen Datentypen müssen auch andere durch Anweisungen angepasst werden, sodass sie in \CS später verwendbar sind. In drei Interface Files sind mehrere so genannte Typemaps und Mappingvorschriften definiert (allgemein kurz erklärt in Paragraph \ref{typemaps}). \emph{POD\_Mapping.i} enthält eine Typemap für die Übersetzung von besonderen Datentypen (siehe Abschnitt \ref{besonderedatentypen}). Das \emph{CppAPi.i} ist gemischt, hier werden kleine Typemaps definiert, sowie verschidene Defines die nur über wenige Zeilen gehen und kein einzelnes Interface File benötigen. Im File \emph{uniplug\_blender\_api\_swig.i} werden alle Klassen der Header-Datei, die in einem Typemap namentlich aufgerufen werden müssen, auf diese Klassen ausgeführt.

\subparagraph{Typemaps}\label{typemaps}
Swig selber enthält schon Code zum Übersetzen von Datentypen von einer Programmiersprache in die andere. Jedoch kann es vorkommen, dass sich Datentypen anders verhalten sollen oder dass, wie in diesem Fall, eigene Datentypen vorliegen, für die Swig keine Übersetzungsvorschriften bereithält. Hierzu können unter anderem so genannte eigene Typemaps erstellt werden, die die Regeln umschreiben oder ganz neu definieren. Verschiedene Arten an Typemaps behandeln dabei unterschiedliche Szenarien, so konvertiert \emph{\%typemap(in)} beispielsweise einen Wert aus der Zielsprache nach C. \emph{\%typemap(out)} geht dagegen in die andere Richtung\footnote{Weitere Informationen zu Typemaps: \url{http://www.swig.org/Doc1.3/Typemaps.html}} . Da bei diesem Projekt viele Klassen automatisch gewrappt werden müssen, durften die Typemaps keine Einzelfälle beschreiben und mussten allgemein für jeden Fall einsetzbar sein. Trotzdem soll an dieser Stelle vor Updates im 3D-Grafikprogramm gewarnt werden: Zwar sollen neue Funktionen durch das Headerfile automatisch aufgenommen und beim nochmaligen Swiggen übersetzt werden, doch kann es vorkommen, das komplett neue Datentypen noch nicht durch Typemaps erfasst werden. Diese müssen dann neu bedacht und angelegt werden. Im Folgenden werden einige der von der Projektgruppe bedachten Datentypen näher beleuchtet.

\subparagraph{Arrays}
Swig mappt Arrays von \CC nach \CS standardmäßig als Pointer, so dass auf der \CS-Seite dann nicht einfach mit einem klassischen \CS-Array gearbeitet werden kann, sondern mit einem \emph{SWIGTYPE\_p\_int} oder \emph{SWIGTYPE\_p\_double}. Mit dem vordefinierten Interface \emph{arrays\_csharp.i} gibt es nur die Möglichkeit, Arrays namentlich mit dem Befehl \emph{\%apply} in ein \CS-Array zu mappen. Das ist für ein Projekt dieser Größe aber nicht passend, da es extrem aufwändig ist, die Namen aller Array herauszusuchen und in das Interface einzutragen und lässt sich so nicht automatisieren. Deshalb wird für Integer-, Float- und Boolean-Arrays Angaben zum Typemapping gemacht, sodass sie, unabhängig von Größe und Namen, zu einem \CS Array und umgekehrt umgewandelt werden (siehe Listing \ref{lst:Arrays}). Aktuell sind jedoch keine Arrays mehr in der Header-Datei enthalten, da sie alle durch den entsprechende Datentyp (VLFOAT3, VLOAT4, VINT3, ...) abgedeckt werden.

\begin{code}[caption={Beispiel Arraymapping},label={lst:Arrays}, escapechar=|]
%typemap(cstype, out="$csclassname") int[ANY] "int[]"
%typemap(csin) int[ANY] " $csinput"
%typemap(imtype) int[ANY] "int[]"
\end{code}

\subparagraph{std::map}

In der Header-Datei treten viele Key-Value Paare vom Typ \emph{std::map<string, int>}, \emph{std::map<int, string>} oder \emph{std::map<string, DATA\_TYPE\footnote{Beliebiger Datentyp}>} auf. Um dieses Konstrukt in ein äquivalentes in \CS zu konvertieren, wird das \emph{std\_map.i} Interface in das Interface eingebunden. Das ermöglicht, diese Key-Value Paare in einen Datentyp zu übersetzen, der die selben Eigenschaften wie ein \CS Dictionary besitzt. Der Name des Datentypen wir im Interface definiert und ist dann in \CS unter diesem Namen zu finden. Der so definierte Datentyp funktioniert im Großen und Ganzen wie ein Dictionary (siehe Listing\ref{lst:stdmap} Zeile\ref{line:stringintmap}). Um ein Key-Value Paar, das einen beliebigen Datentyp enthält, nach \CS mappen zu können, muss für jeden Datentyp ein extra Template erstellt werden. Um hier zumindest ein wenig Copy-Paste-Arbeit zu sparen, wurde per \emph{\%define} ein Template definiert (siehe Listing\ref{lst:stdmap} Zeile\ref{line:stdmapdefine}), das einen Datentyp entgegennimmt, der dann mit einem String zu einem Key-Value Paar zusammengefügt wird. Dieses Template muss dann für jeden Datentyp einmal aufgerufen werden (siehe Listing \ref{lst:stdmap} Zeile \ref{line:stdtemplate}). 

\begin{code}[caption={std::map},label={lst:stdmap}, escapechar=|]
%include "std_map.i"

%template(String_Int_Map)  std::map<std::string, int>;|\label{line:stringintmap}|
	
%define %std_templates(DATA_TYPE)|\label{line:stdmapdefine}|
%template(String_ ## DATA_TYPE ## _Map) std::map<std::string, UniplugBL::DATA_TYPE>;
%enddef

%std_templates(Property);|\label{line:stdtemplate}|
%std_templates(Function);
%std_templates(EnumPropertyItem);
\end{code}

\subparagraph{std::vector}

In der Header-Datei treten drei Fälle des \emph{std::vector<T>} auf. Diese können mit wenig Aufwand unter Verwendung des \emph{std\_vector.i} Interfaces einfach gemappt werden (siehe Listing \ref{lst:stdvector})

\begin{code}[caption={std::vector},label={lst:stdvector}, escapechar=|]
%include "std_vector.i"

%template(IntVector) std::vector<int>;
%template(FloatVector) std::vector<float>;
%template(DoubleVector) std::vector<double>;
\end{code}

\subparagraph{ignore-Regex}
Einige Funktionen der Header-Datei müssen ignoriert werden. Dafür stellt Swig die sogenannte \emph{\%ignore} Anweisung zur Verfügung, mit der man jede beliebige Funktion oder ganze Klassen ignorieren kann, das heißt, sie werden nicht in den Wrapper übernommen. Die Syntax lautet: Zuerst wird die Ignore-Anweisung beschrieben und darauf folgend der Name der zu ignorierenden Funktion. Beispielsweise \emph{\%ignore examplefunction;}. Die Funktion \emph{examplefunction} würde im Wrapper dann nicht existieren. Hier ist der Fall jedoch etwas speziell, da nicht eine bestimmte Funktion ignoriert werden soll, sonder alle Funktionen, die ein bestimmtes Namensschema aufweisen. Um das zu erzielen, wird Patternmaching mit regulären Ausdrücken angewandt. Für die regulären Ausdrücke wird das Perl Schema (PCRE) verwendet. Um ein Pattern zu erkennen und zu ignorieren, weicht die Syntax aber von dem Obengenannten ab. Hier muss mit der \emph{\%rename}-Anweisung, einem regulären Ausdruck und dem Zusatz eines \emph{\$ignore}-Value gearbeitet werden, da \emph{ignore} eigentlich nur ein Sonderfall der \emph{\%rename} Anweisung ist.
Listing \ref{lst:ignore} zeigt wie alle Funktionen, die entweder \emph{sting\_to} oder \emph{to\_string} enthalten, ignoriert werden.

\begin{code}[caption={inoreregex},label={lst:ignore}, escapechar=|]
%rename("%(regex:/(\w*)string_to(\w*)/$ignore/)s") "";
%rename("%(regex:/(\w*)to_string(\w*)/$ignore/)s") "";
\end{code}

\subparagraph{Besondere Datentypen} \label{besonderedatentypen}
Die Header-Datei enthält Datentypen, die Arrays, Vektoren oder Matrizen im 3-dimensionalen Raum repräsentieren, die auf die entsprechenden Datentypen in FUSEE gemappt werden sollen. Dafür wurden verschiedene Datentypen ausprobiert. Zu Beginn wurde ein 3-dimensionaler Vektor als Feld mit drei Elementen getestet. 
Der erste Versuch einfache Arrays zu verwenden, wurde wieder verworfen, da diese nur als Pointer zurückgegeben werden können und dies, wie in Kapitel \ref{sec:header} beschrieben, vermieden werden sollte. Darauf hin wurden diese Datentypen in der Header-Datei auf den Datentyp \emph{std::array<>} geändert. Leider gab es auch in diesem Fall Probleme den Datentyp zu mappen, da seine Eigenschaften nicht denen eines POD entspricht und es so Probleme mit Übergabeparametern diese Typs gibt, da bei Exceptions dieser Typ nicht auf NULL bzw. 0 gecastet werden kann.
Deshalb wurden in der Header-Datei Datentypen definiert, die für sämtliche int-, bool- und float-Arrays verwendet werden. Für diese Art von Datentypen wurden Typemaps geschrieben und auf das entsprechende Äquivalent in Fusee gemappt. Die Typemaps wurden mit der \emph{\#define}-Anweisung definiert, sodass nicht jeder Datentyp extra Typemaps benötigt, sonder diese ähnlich wie bei den \emph{std::map<>} teilweise automatisch übersetzt werden und ein Teil an Tipparbeit und Zeilen Code gespart werden kann.
Das \emph{out}-Typemap (siehe Listing \ref{lst:pods}) weist eine Besonderheit auf, die es theoretisch ermöglichen würde, auch nicht PODs zu übersetzen, da im Falle einer Exception nicht NULL bzw. 0 zurückgegeben wird, sondern ein leeres Objekt des Datentyps \enquote{\emph{null="TYPE\_NAME()"}} (vgl. \ref{lst:pods}, Zeile 1). Diese Lösung wurde jedoch erst sehr spät gefunden, sodass letztendlich bei den neu definierten Datentypen das VFLAOT Prinzip behalten wurde, da so auch alle auftretenden Arrays abgedeckt werden und auf das oben beschrieben Arraymapping verzichtet werden kann. 
\begin{code}[caption={Stark vereinfachtes Beispiel eines Typemaps für VFOAT},label={lst:pods}, escapechar=|]
%define %fusee_pod_typemaps(DATA_TYPE, TYPE_NAME, RESULT)
	%ignore "operator []";
	%ignore TYPE_NAME;
	%typemap(cstype, out="RESULT") TYPE_NAME, TYPE_NAME *
		"RESULT"
		%typemap(imtype, out="RESULT") TYPE_NAME, TYPE_NAME *
		"RESULT /* imtype */"
	%typemap(ctype, out="TYPE_NAME") TYPE_NAME, TYPE_NAME *
		"TYPE_NAME /* ctype */"		
		...
	%typemap(out, null="TYPE_NAME() /* out (null) */") TYPE_NAME
	%{ 
		$result = $1;
	%}
	%typemap(in) TYPE_NAME
	%{
		$1 = *((TYPE_NAME *)&($input));
	%}
	%typemap(csin) TYPE_NAME, TYPE_NAME *
		"$csinput"
	%typemap(csdirectorin, pre="") TYPE_NAME, TYPE_NAME *
		"$iminput"
	%typemap(csdirectorout) TYPE_NAME, TYPE_NAME *
		"$cscall"
	%typemap(csvarin) TYPE_NAME, TYPE_NAME *
	%{
			...
	%}
	%typemap(csvarout) TYPE_NAME, TYPE_NAME *
	%{
			...
	%}
%enddef	

%include "POD_Mapping.i"
%fusee_pod_typemaps(float, UniplugBL::VFLOAT3, Fusee.Math.float3);
\end{code}
