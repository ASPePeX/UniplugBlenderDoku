\mysection{}{Umsetzung} \label{sec:Umsetzung}

\mysubsection{Linda Schey, Sarah Häfele}{SWIG}

Swig ist ein Programmierwerkzeug, dass es ermöglicht in C/\CC~ geschriebenen Programmcode durch höhere Programmiersprachen anzusprechen. Neben einer Vielzahl von Programmier- und Skriptsprachen unterstützt Swig auch \CS~ und eignet sich somit um in\CC~geschrieben Programmcode mit Fusee zu verbinden. Swig wurde gewählt, das es zum einen bereits in dem Cinemea4D-Uniplug von Fusee verwendet wurde und zum anderem nimmt es einem die Arbeit ab einen kompletten Wrapper von Hand zu schreiben, so dass man sich mittels Swig einen Wrapper generieren lassen kann. Zudem erleichtert es die Wartung von Projekten, da Updates im Code nicht von Hand und mühseliger Suche eingetragen werden müssen, sondern lediglich für die neue Generierung des Wrappers die aktuelle Headerfiles eingebunden werden müssen.

Warum SWIG?\\
verwendete software (python, swig, fusee.math)\\\\

SWIG ist nicht intuitiv verwendbar. Bei der Nutzung ist einiges zu beachten, was durch die SWIG Dokumentation nicht gleich ersichtlich ist und erst durch Trial-and-Error langsam erarbeitet werden kann (hier spielen zudem noch das Zusammentreffen von Blender und Fusee mit all ihrer Eigenheiten eine wichtige Rolle, wie später noch besser ersichtlich wird). Deshalb zunächst eine Liste mit Dingen, auf die beim Entwickeln mit SWIG zu achten ist und auf deren Inhalt zum Teil später noch näher eingegangen wird.

\begin{itemize}
\item Den Build der Solution sowie deren Unterprojekte auf Release stellen: Da Blender Python \textcolor{red}{als Kommunikationssprache verwendet und Python ...} muss das Projekt als Release gebaut werden, da sonst \textcolor{red}{?????????} Näheres zu den Buildeinstellungen in \textcolor{red}{...}
\item Die richtige Build-Reihenfolge ist unbedingt zu beachten. Zudem sollten zuvor \emph{geswiggte} Klassen aus dem Ordner gelöscht werden, wenn an ihnen Änderungen vorgenommen wurden, um Fehler durch alte Dateien zu vermeiden. Auf die Reihenfolge soll später näher eingegangen werden (siehe \textcolor{red}{???}).
\item \textcolor{red}{BigObj: wieso, weshalb, warum}
\item Größe des Headerfiles: Aus Sichtweise der SWIG-Entwickler sind einzelne Headerfiles pro Klassen besser zu swiggen als ein großes mit allen gesammelten Klassen. Das Swiggen dauert mit einem großen File dementsprechend lang zum Bauen und tritt ein Fehler auf, muss der ganze Prozess wiederholt werden. Fehler beim Swiggen werden so erst am Ende erkannt. Zudem vermuten das Swig-Team dieses Projektes, dass weitere Komplikationen durch das zu großes File aufgetreten sind. 
\item Die Unterschiede zwischen c++ und c\# müssen verstanden und beachtet werden, da SWIG nicht alle Klassen, Methoden, etc. einfach in die andere Sprache übersetzen kann. Hierzu zählen sicherlich 
	\begin{itemize}
	\item Speicher Allokation
	\item Garbage Collector: Durh den Managed Code in C\# können eventuell Probleme auftreten. Im unmanaged C++-Code sind keine Vorbereitungen für einen eventuellen Garbage Collector getroffen. Wird dieser Code mit SWIG nach C\# übersetzt, kann es Probleme bei Dependencies geben, dann nämlich, wenn der Garbage Collector ein Objekt entfernt, auf das ein anderes zugreifen möchte. Hier kann es zu Programmabstürzen kommen. \textcolor{red}{? Lösungsvorschläge weiter unten}
	\item Default Werte: C++ und C\# gehen unterschiedlich mit Default-Werten um, wenn eine Variable nicht initialisiert wurde. C++ vergibt einen völlig beliebigen Wert, während C\# meist feste Default-Werte hat. Dies ist wiederum bei der Übersetzung mit SWIG zu beachten. 
	\item Pointer: Da die Anwendung C++- in C\#-Code umwandeln soll, treten hier verhäuft Fehler und Komplikationen auf. In Unterkapitel \ref{subsubsec:Datentypen} soll dies eingehend behandelt werden. 
	\end{itemize}
\item Die Spezialfälle werden in der SWIG-Doku nicht ausreichend behandelt, weswegen die Entwickler durch so genannte \emph{Mailing Lists} kontaktiert wurden. Der Dialog mit den Spezialisten bringt neue Erkenntnisse, kann aber nicht alle Spezialfälle klären. Hierzu später ebenfalls mehr.
\item Syntax: Syntaxunterschiede können ebenfalls Komplikationen hervorrufen. Da SWIG hauptsächlich Strings ersetzt, muss die Struktur der jeweiligen Syntax immer beachtet werden. So muss zum Beispiel in c++ der Zeigerstern (*) direkt vor dem Variablennamen stehen, wobei in C\# dieser zur Typendeklaration gehört. \textcolor{red}{???}
\item Debuggen mit SWIG: Da es kein Syntax-Highlighting für SWIG in Visual Studio gibt, ist das Finden von Fehlern im SWIG-Code nicht leicht.  
\end{itemize}



	
	
		


	Ignore Genereated\\


\subsubsection{Aufbau des Projektes in VS}\label{subsubsec:Aufbau}

Um das von Fabi erzeugte \CC~Headerfile nach \CS~zu wrappen wurde eine Solution aufgesetzt die aus fünf Projekten Besteht und den \CC~Code nach \CS~wrappt. Im folgenden werden diese Projekte in der Reihenfolge wie sieh für eine erfolgreiche Generierung des \CS~Codes gebaut werden müssen erläutert.\\


\begin{description}
\item[CppApi]\hfill \\
Enthält das \CC~Headerfile mit allen Klassen und Funktionen. Generiert \emph{CppApi.dll}
\item[SWIG]\hfill \\
Enthält das Swig-Interface \emph{CppApi.i} nach dessen Vorschriften besondere Datentypen geswiggt werden (mehr dazu in \ref{subsubsec:Typemaps}). Generiert anhand des Headerfiles entsprechenden Wrapper in \CS. Diese werden dem \emph{CsWrapper} Projekt hinzugefügt.
\item[CppWrapper]\hfill \\
Enthält das \CC~ File CppApiWrapper.cpp, das ebenfalls durch Swig Generiert wird. Es stellt die Schnittsichtelle zwischen dem \CC~ Code und dem \CS~ Code dar unter Berücksichtigung der durch Swig gemarschallten Typen und deren Umwandlungen. Des weiteren wird die \emph{CppWrapper.dll} generiert. 
\item[CsWrapper]\hfill \\
Generiert CsWrapper.dll die die aus dem SWIG Projekt generierten \CS~Klassen enthält. 
\item[CsClient\_START\_ME]\hfill \\
Ist lediglich ein Test Projekt mit dem der geswiggte Code in \CS~getestet wird. Im Hinblick auf das Uniplug entspräche dies dem Plugin?
\end{description}

  

\subsubsection{Build-Einstellungen in VS}\label{subsubsec:Build}
	Bigobject (C++->Command Line "`/bigobj"' )\\
	Release evtl.


\subsubsection{Typemaps}\label{subsubsec:Typemaps}

Was sind Typemaps und wie funktionieren sie?\\

\subsubsection{Besondere Datentypen}\label{subsubsec:Datentypen}
Besondere Datentypen\\
		- std::array\\
		- FVector3, FVECTOR4, ...\\
		- std::vector, std::map\\
	

Zeigertypen können in C\# nur im unsafe-Kontext verwendet werden. Zudem unterliegen sie weiteren Einschränkungen (Boxing und Unboxing wird nicht unterstützt und sie erben nicht von object). Diese und weitere Gründe bewegen dazu, mit SWIG aus den c++-Pointern andere, entsprechende Typen in C\# zu generieren. Dazu müssen die Objekte, die hinter den betreffenden Klassen stehen, analysiert werden. Was repräsentiert der Objekttyp in Blender? Wie ist dieses Konzept in Fusee umgesetzt? \textcolor{red}{Evtl hier noch ein Beispiel mit Fusee Float3 oder so. Danach typemaps dazu}

--> nicht nullbar, wird aber wie Pointer behandelt. Exception-Fehler usw.

\subsubsection{Das SWIG Interface File}\label{subsubsec:Swiginterface}
Das SWIG Interace File CppApi.i enthält neben den oben genannten Typmaps noch weiter  Uübersetzungsvorgaben.
string
map(mit problemen)\&vector
ignore-Regex


\subsubsection{GC}\label{subsubsec:GC}
